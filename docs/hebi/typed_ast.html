<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/hebi/dev/docs/hebi_32.png" sizes="32x32" type="image/png">
<title>hebi.typed_ast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/hebi" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>hebi.typed_ast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import typing
from ast import *
from dataclasses import dataclass

from frozenlist import FrozenList

import pluthon as plt
import uplc.ast as uplc


def distinct(xs: list):
    &#34;&#34;&#34;Returns true iff the list consists of distinct elements&#34;&#34;&#34;
    return len(xs) == len(set(xs))


def FrozenFrozenList(l: list):
    fl = FrozenList(l)
    fl.freeze()
    return fl


class Type:
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have a constructor&#34;
        )

    def constr(self) -&gt; plt.AST:
        &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Constructor of {self.__class__} not implemented&#34;)

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have attribute {attr}&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
        )


@dataclass(frozen=True, unsafe_hash=True)
class Record:
    name: str
    constructor: int
    fields: typing.Union[typing.List[typing.Tuple[str, Type]], FrozenList]


@dataclass(frozen=True, unsafe_hash=True)
class ClassType(Type):
    def __ge__(self, other):
        raise NotImplementedError(&#34;Comparison between raw classtypes impossible&#34;)


@dataclass(frozen=True, unsafe_hash=True)
class AnyType(ClassType):
    &#34;&#34;&#34;The top element in the partial order on types&#34;&#34;&#34;

    def __ge__(self, other):
        return True


@dataclass(frozen=True, unsafe_hash=True)
class AtomicType(ClassType):
    def __ge__(self, other):
        # Can only substitute for its own type (also subtypes)
        return isinstance(other, self.__class__)


@dataclass(frozen=True, unsafe_hash=True)
class RecordType(ClassType):
    record: Record

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(
            FunctionType([f[1] for f in self.record.fields], InstanceType(self))
        )

    def constr(self) -&gt; plt.AST:
        # wrap all constructor values to PlutusData
        build_constr_params = plt.EmptyDataList()
        for n, t in reversed(self.record.fields):
            build_constr_params = plt.MkCons(
                transform_output_map(t)(plt.Var(n)), build_constr_params
            )
        # then build a constr type with this PlutusData
        return plt.Lambda(
            [&#34;_&#34;] + [n for n, _ in self.record.fields],
            plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
        )

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        for n, t in self.record.fields:
            if n == attr:
                return t
        raise TypeInferenceError(
            f&#34;Type {self.record.name} does not have attribute {attr}&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return plt.Lambda(
                [&#34;self&#34;],
                plt.Constructor(plt.Var(&#34;self&#34;)),
            )
        attr_typ = self.attribute_type(attr)
        pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
        # access to normal fields
        return plt.Lambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.NthField(
                    plt.Var(&#34;self&#34;),
                    plt.Integer(pos),
                ),
            ),
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (isinstance(o, RecordType) and o.record == self.record) or (
            isinstance(o, UnionType) and self in o.typs
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            plt.Var(&#34;x&#34;),
                            plt.Var(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and o.typ.typ &gt;= self
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsData(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData), plt.Var(&#34;x&#34;)
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.ConstrData(
                                plt.AddInteger(
                                    plt.Constructor(plt.Var(&#34;x&#34;)), plt.Integer(1)
                                ),
                                plt.MkNilData(plt.Unit()),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def __ge__(self, other):
        # Can only substitute for its own type, records need to be equal
        # if someone wants to be funny, they can implement &lt;= to be true if all fields match up to some point
        return isinstance(other, self.__class__) and other.record == self.record


@dataclass(frozen=True, unsafe_hash=True)
class UnionType(ClassType):
    typs: typing.List[RecordType]

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        # iterate through all names/types of the unioned records by position
        for attr_names, attr_types in map(
            lambda x: zip(*x), zip(*(t.record.fields for t in self.typs))
        ):
            # need to have a common field with the same name, in the same position!
            if any(attr_name != attr for attr_name in attr_names):
                continue
            for at in attr_types:
                # return the maximum element if there is one
                if all(at &gt;= at2 for at2 in attr_types):
                    return at
            # return the union type of all possible instantiations if all possible values are record types
            if all(
                isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
                for at in attr_types
            ) and distinct([at.typ.record.constructor for at in attr_types]):
                return InstanceType(
                    UnionType(FrozenFrozenList([at.typ for at in attr_types]))
                )
            # return Anytype
            return InstanceType(AnyType())
        raise TypeInferenceError(
            f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return plt.Lambda(
                [&#34;self&#34;],
                plt.Constructor(plt.Var(&#34;self&#34;)),
            )
        # iterate through all names/types of the unioned records by position
        attr_typ = self.attribute_type(attr)
        pos = next(
            i
            for i, (ns, _) in enumerate(
                map(lambda x: zip(*x), zip(*(t.record.fields for t in self.typs)))
            )
            if all(n == attr for n in ns)
        )
        # access to normal fields
        return plt.Lambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.NthField(
                    plt.Var(&#34;self&#34;),
                    plt.Integer(pos),
                ),
            ),
        )

    def __ge__(self, other):
        if isinstance(other, UnionType):
            return all(any(t &gt;= ot for ot in other.typs) for t in self.typs)
        return any(t &gt;= other for t in self.typs)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        # note we require that there is an overlapt between the possible types for unions
        if (isinstance(o, RecordType) and o in self.typs) or (
            isinstance(o, UnionType) and set(self.typs).intersection(o.typs)
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            plt.Var(&#34;x&#34;),
                            plt.Var(&#34;y&#34;),
                        )
                    ),
                )
        raise NotImplementedError(
            f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
        )


@dataclass(frozen=True, unsafe_hash=True)
class TupleType(ClassType):
    typs: typing.List[Type]

    def __ge__(self, other):
        return isinstance(other, TupleType) and all(
            t &gt;= ot for t, ot in zip(self.typs, other.typs)
        )


@dataclass(frozen=True, unsafe_hash=True)
class PairType(ClassType):
    &#34;&#34;&#34;An internal type representing built-in PlutusData pairs&#34;&#34;&#34;

    l_typ: Type
    r_typ: Type

    def __ge__(self, other):
        return isinstance(other, PairType) and all(
            t &gt;= ot
            for t, ot in zip((self.l_typ, self.r_typ), (other.l_typ, other.r_typ))
        )


@dataclass(frozen=True, unsafe_hash=True)
class ListType(ClassType):
    typ: Type

    def __ge__(self, other):
        return isinstance(other, ListType) and self.typ &gt;= other.typ


@dataclass(frozen=True, unsafe_hash=True)
class DictType(ClassType):
    key_typ: Type
    value_typ: Type

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;get&#34;:
            return InstanceType(
                FunctionType([self.key_typ, self.value_typ], self.value_typ)
            )
        if attr == &#34;keys&#34;:
            return InstanceType(FunctionType([], InstanceType(ListType(self.key_typ))))
        if attr == &#34;values&#34;:
            return InstanceType(
                FunctionType([], InstanceType(ListType(self.value_typ)))
            )
        if attr == &#34;items&#34;:
            return InstanceType(
                FunctionType(
                    [],
                    InstanceType(
                        ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                    ),
                )
            )
        raise TypeInferenceError(
            f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;get&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;, &#34;key&#34;, &#34;default&#34;],
                transform_ext_params_map(self.value_typ)(
                    plt.SndPair(
                        plt.FindList(
                            plt.Var(&#34;self&#34;),
                            plt.Lambda(
                                [&#34;x&#34;],
                                plt.EqualsData(
                                    transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                                    plt.FstPair(plt.Var(&#34;x&#34;)),
                                ),
                            ),
                            # this is a bit ugly... we wrap - only to later unwrap again
                            plt.MkPairData(
                                transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                                transform_output_map(self.value_typ)(
                                    plt.Var(&#34;default&#34;)
                                ),
                            ),
                        ),
                    ),
                ),
            )
        if attr == &#34;keys&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    plt.Var(&#34;self&#34;),
                    plt.Lambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.key_typ)(
                            plt.FstPair(plt.Var(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.key_typ),
                ),
            )
        if attr == &#34;values&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    plt.Var(&#34;self&#34;),
                    plt.Lambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.value_typ)(
                            plt.SndPair(plt.Var(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.value_typ),
                ),
            )
        if attr == &#34;items&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.Var(&#34;self&#34;),
            )
        raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)

    def __ge__(self, other):
        return (
            isinstance(other, DictType)
            and self.key_typ &gt;= other.key_typ
            and self.value_typ &gt;= other.value_typ
        )


@dataclass(frozen=True, unsafe_hash=True)
class FunctionType(ClassType):
    argtyps: typing.List[Type]
    rettyp: Type

    def __ge__(self, other):
        return (
            isinstance(other, FunctionType)
            and all(a &gt;= oa for a, oa in zip(self.argtyps, other.argtyps))
            and other.rettyp &gt;= self.rettyp
        )


@dataclass(frozen=True, unsafe_hash=True)
class InstanceType(Type):
    typ: ClassType

    def constr_type(self) -&gt; FunctionType:
        raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)

    def constr(self) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)

    def attribute_type(self, attr) -&gt; Type:
        return self.typ.attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        return self.typ.attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, InstanceType):
            return self.typ.cmp(op, o.typ)
        return super().cmp(op, o)

    def __ge__(self, other):
        return isinstance(other, InstanceType) and self.typ &gt;= other.typ


@dataclass(frozen=True, unsafe_hash=True)
class IntegerType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(FunctionType([StringInstanceType], InstanceType(self)))

    def constr(self) -&gt; plt.AST:
        # TODO we need to strip the string implicitely before parsing it
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;],
            plt.Let(
                [
                    (&#34;e&#34;, plt.EncodeUtf8(plt.Var(&#34;x&#34;))),
                    (&#34;first_int&#34;, plt.IndexByteString(plt.Var(&#34;e&#34;), plt.Integer(0))),
                    (&#34;len&#34;, plt.LengthOfByteString(plt.Var(&#34;e&#34;))),
                    (
                        &#34;fold_start&#34;,
                        plt.Lambda(
                            [&#34;start&#34;],
                            plt.FoldList(
                                plt.Range(plt.Var(&#34;len&#34;), plt.Var(&#34;start&#34;)),
                                plt.Lambda(
                                    [&#34;s&#34;, &#34;i&#34;],
                                    plt.Let(
                                        [
                                            (
                                                &#34;b&#34;,
                                                plt.IndexByteString(
                                                    plt.Var(&#34;e&#34;), plt.Var(&#34;i&#34;)
                                                ),
                                            )
                                        ],
                                        plt.Ite(
                                            plt.EqualsInteger(
                                                plt.Var(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                            ),
                                            plt.Var(&#34;s&#34;),
                                            plt.Ite(
                                                plt.Or(
                                                    plt.LessThanInteger(
                                                        plt.Var(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.LessThanInteger(
                                                        plt.Integer(ord(&#34;9&#34;)),
                                                        plt.Var(&#34;b&#34;),
                                                    ),
                                                ),
                                                plt.TraceError(
                                                    &#34;ValueError: invalid literal for int() with base 10&#34;
                                                ),
                                                plt.AddInteger(
                                                    plt.SubtractInteger(
                                                        plt.Var(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.MultiplyInteger(
                                                        plt.Var(&#34;s&#34;), plt.Integer(10)
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.Integer(0),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.Or(
                        plt.EqualsInteger(plt.Var(&#34;len&#34;), plt.Integer(0)),
                        plt.EqualsInteger(
                            plt.Var(&#34;first_int&#34;),
                            plt.Integer(ord(&#34;_&#34;)),
                        ),
                    ),
                    plt.TraceError(
                        &#34;ValueError: invalid literal for int() with base 10&#34;
                    ),
                    plt.Ite(
                        plt.EqualsInteger(
                            plt.Var(&#34;first_int&#34;),
                            plt.Integer(ord(&#34;-&#34;)),
                        ),
                        plt.Negate(
                            plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(1)),
                        ),
                        plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(0)),
                    ),
                ),
            ),
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Ite(
                        plt.Var(&#34;y&#34;),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                            plt.Var(&#34;y&#34;),
                            plt.Var(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
            if isinstance(op, Gt):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, IntegerType)
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsInteger(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), plt.Var(&#34;x&#34;)
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.AddInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        ),
                    ),
                )
        return super().cmp(op, o)


@dataclass(frozen=True, unsafe_hash=True)
class StringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(FunctionType([IntegerInstanceType], InstanceType(self)))

    def constr(self) -&gt; plt.AST:
        # constructs a string representation of an integer
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;],
            plt.DecodeUtf8(
                plt.Let(
                    [
                        (
                            &#34;strlist&#34;,
                            plt.RecFun(
                                plt.Lambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanEqualsInteger(
                                            plt.Var(&#34;i&#34;), plt.Integer(0)
                                        ),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.AddInteger(
                                                plt.ModInteger(
                                                    plt.Var(&#34;i&#34;), plt.Integer(10)
                                                ),
                                                plt.Integer(ord(&#34;0&#34;)),
                                            ),
                                            plt.Apply(
                                                plt.Var(&#34;f&#34;),
                                                plt.Var(&#34;f&#34;),
                                                plt.DivideInteger(
                                                    plt.Var(&#34;i&#34;), plt.Integer(10)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            plt.Lambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(plt.Var(&#34;strlist&#34;), plt.Var(&#34;i&#34;)),
                                    plt.Lambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ByteString(b&#34;0&#34;),
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                            plt.ConsByteString(
                                plt.Integer(ord(&#34;-&#34;)),
                                plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                            plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                )
            ),
        )

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;encode&#34;:
            return InstanceType(FunctionType([], ByteStringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;encode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(plt.Var(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, StringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
        return super().cmp(op, o)


@dataclass(frozen=True, unsafe_hash=True)
class ByteStringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(
            FunctionType(
                [InstanceType(ListType(IntegerInstanceType))], InstanceType(self)
            )
        )

    def constr(self) -&gt; plt.AST:
        return plt.Lambda(
            [&#34;_&#34;, &#34;xs&#34;],
            plt.RFoldList(
                plt.Var(&#34;xs&#34;),
                plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
                plt.ByteString(b&#34;&#34;),
            ),
        )

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;decode&#34;:
            return InstanceType(FunctionType([], StringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;decode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(plt.Var(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, ByteStringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            plt.Var(&#34;y&#34;),
                            plt.Var(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
            if isinstance(op, Gt):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, ByteStringType)
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsByteString(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                                plt.Var(&#34;x&#34;),
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.ConsByteString(plt.Integer(0), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                )
        return super().cmp(op, o)


@dataclass(frozen=True, unsafe_hash=True)
class BoolType(AtomicType):
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(FunctionType([IntegerInstanceType], BoolInstanceType))

    def constr(self) -&gt; plt.AST:
        # constructs a boolean from an integer
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;], plt.Not(plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)))
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return plt.Lambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        plt.Var(&#34;y&#34;),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(plt.Var(&#34;x&#34;), plt.Var(&#34;y&#34;)))
        return super().cmp(op, o)


@dataclass(frozen=True, unsafe_hash=True)
class UnitType(AtomicType):
    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, UnitType):
            if isinstance(op, Eq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
            if isinstance(op, NotEq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
        return super().cmp(op, o)


IntegerInstanceType = InstanceType(IntegerType())
StringInstanceType = InstanceType(StringType())
ByteStringInstanceType = InstanceType(ByteStringType())
BoolInstanceType = InstanceType(BoolType())
UnitInstanceType = InstanceType(UnitType())

ATOMIC_TYPES = {
    int.__name__: IntegerType(),
    str.__name__: StringType(),
    bytes.__name__: ByteStringType(),
    &#34;Unit&#34;: UnitType(),
    bool.__name__: BoolType(),
}


NoneInstanceType = UnitInstanceType


class InaccessibleType(ClassType):
    &#34;&#34;&#34;A type that blocks overwriting of a function&#34;&#34;&#34;

    pass


class PolymorphicFunction:
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        raise NotImplementedError()

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        raise NotImplementedError()


@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionType(ClassType):
    &#34;&#34;&#34;A special type of builtin that may act differently on different parameters&#34;&#34;&#34;

    polymorphic_function: PolymorphicFunction


@dataclass(frozen=True, unsafe_hash=True)
class PolymorphicFunctionInstanceType(InstanceType):
    typ: FunctionType
    polymorphic_function: PolymorphicFunction


class TypedAST(AST):
    typ: Type


class typedexpr(TypedAST, expr):
    pass


class typedstmt(TypedAST, stmt):
    # Statements always have type None
    typ = NoneInstanceType


class typedarg(TypedAST, arg):
    pass


class typedarguments(TypedAST, arguments):
    args: typing.List[typedarg]
    vararg: typing.Union[typedarg, None]
    kwonlyargs: typing.List[typedarg]
    kw_defaults: typing.List[typing.Union[typedexpr, None]]
    kwarg: typing.Union[typedarg, None]
    defaults: typing.List[typedexpr]


class TypedModule(typedstmt, Module):
    body: typing.List[typedstmt]


class TypedFunctionDef(typedstmt, FunctionDef):
    body: typing.List[typedstmt]
    args: arguments


class TypedIf(typedstmt, If):
    test: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]


class TypedReturn(typedstmt, Return):
    value: typedexpr


class TypedExpression(typedexpr, Expression):
    body: typedexpr


class TypedCall(typedexpr, Call):
    func: typedexpr
    args: typing.List[typedexpr]


class TypedExpr(typedstmt, Expr):
    value: typedexpr


class TypedAssign(typedstmt, Assign):
    targets: typing.List[typedexpr]
    value: typedexpr


class TypedClassDef(typedstmt, ClassDef):
    class_typ: Type


class TypedAnnAssign(typedstmt, AnnAssign):
    target: typedexpr
    annotation: Type
    value: typedexpr


class TypedWhile(typedstmt, While):
    test: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]


class TypedFor(typedstmt, For):
    target: typedexpr
    iter: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]


class TypedPass(typedstmt, Pass):
    pass


class TypedName(typedexpr, Name):
    pass


class TypedConstant(TypedAST, Constant):
    pass


class TypedTuple(typedexpr, Tuple):
    pass


class TypedList(typedexpr, List):
    pass


class typedcomprehension(typedexpr, comprehension):
    target: typedexpr
    iter: typedexpr
    ifs: typing.List[typedexpr]


class TypedListComp(typedexpr, ListComp):
    generators: typing.List[typedcomprehension]
    elt: typedexpr


class TypedDict(typedexpr, Dict):
    pass


class TypedIfExp(typedstmt, IfExp):
    test: typedexpr
    body: typedexpr
    orelse: typedexpr


class TypedCompare(typedexpr, Compare):
    left: typedexpr
    ops: typing.List[cmpop]
    comparators: typing.List[typedexpr]


class TypedBinOp(typedexpr, BinOp):
    left: typedexpr
    right: typedexpr


class TypedBoolOp(typedexpr, BoolOp):
    values: typing.List[typedexpr]


class TypedUnaryOp(typedexpr, UnaryOp):
    operand: typedexpr


class TypedSubscript(typedexpr, Subscript):
    value: typedexpr


class TypedAttribute(typedexpr, Attribute):
    value: typedexpr
    pos: int


class TypedAssert(typedstmt, Assert):
    test: typedexpr
    msg: typedexpr


class RawPlutoExpr(typedexpr):
    typ: Type
    expr: plt.AST


class TypeInferenceError(AssertionError):
    pass


EmptyListMap = {
    IntegerInstanceType: plt.EmptyIntegerList(),
    ByteStringInstanceType: plt.EmptyByteStringList(),
    StringInstanceType: plt.EmptyTextList(),
    UnitInstanceType: plt.EmptyUnitList(),
    BoolInstanceType: plt.EmptyBoolList(),
}


def empty_list(p: Type):
    if p in EmptyListMap:
        return EmptyListMap[p]
    assert isinstance(p, InstanceType), &#34;Can only create lists of instances&#34;
    if isinstance(p.typ, ListType):
        el = empty_list(p.typ.typ)
        return plt.EmptyListList(uplc.BuiltinList([], el.sample_value))
    if isinstance(p.typ, DictType):
        return plt.EmptyListList(
            uplc.BuiltinList(
                [],
                uplc.BuiltinPair(
                    uplc.PlutusConstr(0, FrozenList([])),
                    uplc.PlutusConstr(0, FrozenList([])),
                ),
            )
        )
    if isinstance(p.typ, RecordType) or isinstance(p.typ, AnyType):
        return plt.EmptyDataList()
    raise NotImplementedError(f&#34;Empty lists of type {p} can&#39;t be constructed yet&#34;)


TransformExtParamsMap = {
    IntegerInstanceType: lambda x: plt.UnIData(x),
    ByteStringInstanceType: lambda x: plt.UnBData(x),
    StringInstanceType: lambda x: plt.DecodeUtf8(plt.UnBData(x)),
    UnitInstanceType: lambda x: plt.Apply(plt.Lambda([&#34;_&#34;], plt.Unit())),
    BoolInstanceType: lambda x: plt.NotEqualsInteger(plt.UnIData(x), plt.Integer(0)),
}


def transform_ext_params_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformExtParamsMap:
        return TransformExtParamsMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.MapList(
            plt.UnListData(x),
            plt.Lambda([&#34;x&#34;], transform_ext_params_map(list_int_typ)(plt.Var(&#34;x&#34;))),
            empty_list(p.typ.typ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.UnMapData(x)
    return lambda x: x


TransformOutputMap = {
    StringInstanceType: lambda x: plt.BData(plt.EncodeUtf8(x)),
    IntegerInstanceType: lambda x: plt.IData(x),
    ByteStringInstanceType: lambda x: plt.BData(x),
    UnitInstanceType: lambda x: plt.Apply(plt.Lambda([&#34;_&#34;], plt.Unit()), x),
    BoolInstanceType: lambda x: plt.IData(
        plt.IfThenElse(x, plt.Integer(1), plt.Integer(0))
    ),
}


def transform_output_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformOutputMap:
        return TransformOutputMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.ListData(
            plt.MapList(
                x,
                plt.Lambda([&#34;x&#34;], transform_output_map(list_int_typ)(plt.Var(&#34;x&#34;))),
            ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.MapData(x)
    return lambda x: x


class TypedNodeTransformer(NodeTransformer):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)


class TypedNodeVisitor(NodeVisitor):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hebi.typed_ast.FrozenFrozenList"><code class="name flex">
<span>def <span class="ident">FrozenFrozenList</span></span>(<span>l: list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FrozenFrozenList(l: list):
    fl = FrozenList(l)
    fl.freeze()
    return fl</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.distinct"><code class="name flex">
<span>def <span class="ident">distinct</span></span>(<span>xs: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff the list consists of distinct elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distinct(xs: list):
    &#34;&#34;&#34;Returns true iff the list consists of distinct elements&#34;&#34;&#34;
    return len(xs) == len(set(xs))</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.empty_list"><code class="name flex">
<span>def <span class="ident">empty_list</span></span>(<span>p: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty_list(p: Type):
    if p in EmptyListMap:
        return EmptyListMap[p]
    assert isinstance(p, InstanceType), &#34;Can only create lists of instances&#34;
    if isinstance(p.typ, ListType):
        el = empty_list(p.typ.typ)
        return plt.EmptyListList(uplc.BuiltinList([], el.sample_value))
    if isinstance(p.typ, DictType):
        return plt.EmptyListList(
            uplc.BuiltinList(
                [],
                uplc.BuiltinPair(
                    uplc.PlutusConstr(0, FrozenList([])),
                    uplc.PlutusConstr(0, FrozenList([])),
                ),
            )
        )
    if isinstance(p.typ, RecordType) or isinstance(p.typ, AnyType):
        return plt.EmptyDataList()
    raise NotImplementedError(f&#34;Empty lists of type {p} can&#39;t be constructed yet&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.transform_ext_params_map"><code class="name flex">
<span>def <span class="ident">transform_ext_params_map</span></span>(<span>p: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_ext_params_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformExtParamsMap:
        return TransformExtParamsMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.MapList(
            plt.UnListData(x),
            plt.Lambda([&#34;x&#34;], transform_ext_params_map(list_int_typ)(plt.Var(&#34;x&#34;))),
            empty_list(p.typ.typ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.UnMapData(x)
    return lambda x: x</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.transform_output_map"><code class="name flex">
<span>def <span class="ident">transform_output_map</span></span>(<span>p: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_output_map(p: Type):
    assert isinstance(
        p, InstanceType
    ), &#34;Can only transform instances, not classes as input&#34;
    if p in TransformOutputMap:
        return TransformOutputMap[p]
    if isinstance(p.typ, ListType):
        list_int_typ = p.typ.typ
        return lambda x: plt.ListData(
            plt.MapList(
                x,
                plt.Lambda([&#34;x&#34;], transform_output_map(list_int_typ)(plt.Var(&#34;x&#34;))),
            ),
        )
    if isinstance(p.typ, DictType):
        # there doesn&#39;t appear to be a constructor function to make Pair a b for any types
        # so pairs will always contain Data
        return lambda x: plt.MapData(x)
    return lambda x: x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hebi.typed_ast.AnyType"><code class="flex name class">
<span>class <span class="ident">AnyType</span></span>
</code></dt>
<dd>
<div class="desc"><p>The top element in the partial order on types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnyType(ClassType):
    &#34;&#34;&#34;The top element in the partial order on types&#34;&#34;&#34;

    def __ge__(self, other):
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.AnyType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.AnyType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.AnyType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.AnyType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.AnyType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.AtomicType"><code class="flex name class">
<span>class <span class="ident">AtomicType</span></span>
</code></dt>
<dd>
<div class="desc"><p>AtomicType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtomicType(ClassType):
    def __ge__(self, other):
        # Can only substitute for its own type (also subtypes)
        return isinstance(other, self.__class__)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.BoolType" href="#hebi.typed_ast.BoolType">BoolType</a></li>
<li><a title="hebi.typed_ast.ByteStringType" href="#hebi.typed_ast.ByteStringType">ByteStringType</a></li>
<li><a title="hebi.typed_ast.IntegerType" href="#hebi.typed_ast.IntegerType">IntegerType</a></li>
<li><a title="hebi.typed_ast.StringType" href="#hebi.typed_ast.StringType">StringType</a></li>
<li><a title="hebi.typed_ast.UnitType" href="#hebi.typed_ast.UnitType">UnitType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.AtomicType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.AtomicType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.AtomicType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.AtomicType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.AtomicType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.BoolType"><code class="flex name class">
<span>class <span class="ident">BoolType</span></span>
</code></dt>
<dd>
<div class="desc"><p>BoolType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoolType(AtomicType):
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(FunctionType([IntegerInstanceType], BoolInstanceType))

    def constr(self) -&gt; plt.AST:
        # constructs a boolean from an integer
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;], plt.Not(plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)))
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return plt.Lambda(
                    [&#34;y&#34;, &#34;x&#34;],
                    plt.Ite(
                        plt.Var(&#34;y&#34;),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(plt.Var(&#34;x&#34;), plt.Var(&#34;y&#34;)))
        return super().cmp(op, o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.BoolType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.BoolType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.BoolType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, IntegerType):
        if isinstance(op, Eq):
            # 1 == True
            # 0 == False
            # all other comparisons are False
            return plt.Lambda(
                [&#34;y&#34;, &#34;x&#34;],
                plt.Ite(
                    plt.Var(&#34;y&#34;),
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                ),
            )
    if isinstance(o, BoolType):
        if isinstance(op, Eq):
            return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Iff(plt.Var(&#34;x&#34;), plt.Var(&#34;y&#34;)))
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.BoolType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    # constructs a boolean from an integer
    return plt.Lambda(
        [&#34;_&#34;, &#34;x&#34;], plt.Not(plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)))
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.BoolType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    return InstanceType(FunctionType([IntegerInstanceType], BoolInstanceType))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.ByteStringType"><code class="flex name class">
<span>class <span class="ident">ByteStringType</span></span>
</code></dt>
<dd>
<div class="desc"><p>ByteStringType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ByteStringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(
            FunctionType(
                [InstanceType(ListType(IntegerInstanceType))], InstanceType(self)
            )
        )

    def constr(self) -&gt; plt.AST:
        return plt.Lambda(
            [&#34;_&#34;, &#34;xs&#34;],
            plt.RFoldList(
                plt.Var(&#34;xs&#34;),
                plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
                plt.ByteString(b&#34;&#34;),
            ),
        )

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;decode&#34;:
            return InstanceType(FunctionType([], StringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;decode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(plt.Var(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, ByteStringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            plt.Var(&#34;y&#34;),
                            plt.Var(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
            if isinstance(op, Gt):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, ByteStringType)
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsByteString(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                                plt.Var(&#34;x&#34;),
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.ConsByteString(plt.Integer(0), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                )
        return super().cmp(op, o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.ByteStringType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;decode&#34;:
        # No codec -&gt; only the default (utf8) is allowed
        return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.DecodeUtf8(plt.Var(&#34;x&#34;)))
    return super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.ByteStringType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    if attr == &#34;decode&#34;:
        return InstanceType(FunctionType([], StringInstanceType))
    return super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.ByteStringType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, ByteStringType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsByteString)
        if isinstance(op, NotEq):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    )
                ),
            )
        if isinstance(op, Lt):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanByteString)
        if isinstance(op, LtE):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString)
        if isinstance(op, Gt):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanByteString),
                    plt.Var(&#34;y&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            )
        if isinstance(op, GtE):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsByteString),
                    plt.Var(&#34;y&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and isinstance(o.typ.typ, ByteStringType)
    ):
        if isinstance(op, In):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.EqualsByteString(
                    plt.Var(&#34;x&#34;),
                    plt.FindList(
                        plt.Var(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsByteString),
                            plt.Var(&#34;x&#34;),
                        ),
                        # this simply ensures the default is always unequal to the searched value
                        plt.ConsByteString(plt.Integer(0), plt.Var(&#34;x&#34;)),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.ByteStringType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    return plt.Lambda(
        [&#34;_&#34;, &#34;xs&#34;],
        plt.RFoldList(
            plt.Var(&#34;xs&#34;),
            plt.Lambda([&#34;a&#34;, &#34;x&#34;], plt.ConsByteString(plt.Var(&#34;x&#34;), plt.Var(&#34;a&#34;))),
            plt.ByteString(b&#34;&#34;),
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.ByteStringType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(
        FunctionType(
            [InstanceType(ListType(IntegerInstanceType))], InstanceType(self)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.ClassType"><code class="flex name class">
<span>class <span class="ident">ClassType</span></span>
</code></dt>
<dd>
<div class="desc"><p>ClassType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassType(Type):
    def __ge__(self, other):
        raise NotImplementedError(&#34;Comparison between raw classtypes impossible&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.rewrite.rewrite_import_hashlib.HashType" href="rewrite/rewrite_import_hashlib.html#hebi.rewrite.rewrite_import_hashlib.HashType">HashType</a></li>
<li><a title="hebi.typed_ast.AnyType" href="#hebi.typed_ast.AnyType">AnyType</a></li>
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.DictType" href="#hebi.typed_ast.DictType">DictType</a></li>
<li><a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></li>
<li><a title="hebi.typed_ast.InaccessibleType" href="#hebi.typed_ast.InaccessibleType">InaccessibleType</a></li>
<li><a title="hebi.typed_ast.ListType" href="#hebi.typed_ast.ListType">ListType</a></li>
<li><a title="hebi.typed_ast.PairType" href="#hebi.typed_ast.PairType">PairType</a></li>
<li><a title="hebi.typed_ast.PolymorphicFunctionType" href="#hebi.typed_ast.PolymorphicFunctionType">PolymorphicFunctionType</a></li>
<li><a title="hebi.typed_ast.RecordType" href="#hebi.typed_ast.RecordType">RecordType</a></li>
<li><a title="hebi.typed_ast.TupleType" href="#hebi.typed_ast.TupleType">TupleType</a></li>
<li><a title="hebi.typed_ast.UnionType" href="#hebi.typed_ast.UnionType">UnionType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.ClassType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.attribute" href="#hebi.typed_ast.Type.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.ClassType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.attribute_type" href="#hebi.typed_ast.Type.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.ClassType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.cmp" href="#hebi.typed_ast.Type.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.ClassType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.constr" href="#hebi.typed_ast.Type.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.ClassType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.constr_type" href="#hebi.typed_ast.Type.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.DictType"><code class="flex name class">
<span>class <span class="ident">DictType</span></span>
<span>(</span><span>key_typ: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>, value_typ: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>DictType(key_typ: hebi.typed_ast.Type, value_typ: hebi.typed_ast.Type)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictType(ClassType):
    key_typ: Type
    value_typ: Type

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;get&#34;:
            return InstanceType(
                FunctionType([self.key_typ, self.value_typ], self.value_typ)
            )
        if attr == &#34;keys&#34;:
            return InstanceType(FunctionType([], InstanceType(ListType(self.key_typ))))
        if attr == &#34;values&#34;:
            return InstanceType(
                FunctionType([], InstanceType(ListType(self.value_typ)))
            )
        if attr == &#34;items&#34;:
            return InstanceType(
                FunctionType(
                    [],
                    InstanceType(
                        ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                    ),
                )
            )
        raise TypeInferenceError(
            f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;get&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;, &#34;key&#34;, &#34;default&#34;],
                transform_ext_params_map(self.value_typ)(
                    plt.SndPair(
                        plt.FindList(
                            plt.Var(&#34;self&#34;),
                            plt.Lambda(
                                [&#34;x&#34;],
                                plt.EqualsData(
                                    transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                                    plt.FstPair(plt.Var(&#34;x&#34;)),
                                ),
                            ),
                            # this is a bit ugly... we wrap - only to later unwrap again
                            plt.MkPairData(
                                transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                                transform_output_map(self.value_typ)(
                                    plt.Var(&#34;default&#34;)
                                ),
                            ),
                        ),
                    ),
                ),
            )
        if attr == &#34;keys&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    plt.Var(&#34;self&#34;),
                    plt.Lambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.key_typ)(
                            plt.FstPair(plt.Var(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.key_typ),
                ),
            )
        if attr == &#34;values&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.MapList(
                    plt.Var(&#34;self&#34;),
                    plt.Lambda(
                        [&#34;x&#34;],
                        transform_ext_params_map(self.value_typ)(
                            plt.SndPair(plt.Var(&#34;x&#34;))
                        ),
                    ),
                    empty_list(self.value_typ),
                ),
            )
        if attr == &#34;items&#34;:
            return plt.Lambda(
                [&#34;self&#34;, &#34;_&#34;],
                plt.Var(&#34;self&#34;),
            )
        raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)

    def __ge__(self, other):
        return (
            isinstance(other, DictType)
            and self.key_typ &gt;= other.key_typ
            and self.value_typ &gt;= other.value_typ
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.DictType.key_typ"><code class="name">var <span class="ident">key_typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.DictType.value_typ"><code class="name">var <span class="ident">value_typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.DictType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;get&#34;:
        return plt.Lambda(
            [&#34;self&#34;, &#34;_&#34;, &#34;key&#34;, &#34;default&#34;],
            transform_ext_params_map(self.value_typ)(
                plt.SndPair(
                    plt.FindList(
                        plt.Var(&#34;self&#34;),
                        plt.Lambda(
                            [&#34;x&#34;],
                            plt.EqualsData(
                                transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                                plt.FstPair(plt.Var(&#34;x&#34;)),
                            ),
                        ),
                        # this is a bit ugly... we wrap - only to later unwrap again
                        plt.MkPairData(
                            transform_output_map(self.key_typ)(plt.Var(&#34;key&#34;)),
                            transform_output_map(self.value_typ)(
                                plt.Var(&#34;default&#34;)
                            ),
                        ),
                    ),
                ),
            ),
        )
    if attr == &#34;keys&#34;:
        return plt.Lambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.MapList(
                plt.Var(&#34;self&#34;),
                plt.Lambda(
                    [&#34;x&#34;],
                    transform_ext_params_map(self.key_typ)(
                        plt.FstPair(plt.Var(&#34;x&#34;))
                    ),
                ),
                empty_list(self.key_typ),
            ),
        )
    if attr == &#34;values&#34;:
        return plt.Lambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.MapList(
                plt.Var(&#34;self&#34;),
                plt.Lambda(
                    [&#34;x&#34;],
                    transform_ext_params_map(self.value_typ)(
                        plt.SndPair(plt.Var(&#34;x&#34;))
                    ),
                ),
                empty_list(self.value_typ),
            ),
        )
    if attr == &#34;items&#34;:
        return plt.Lambda(
            [&#34;self&#34;, &#34;_&#34;],
            plt.Var(&#34;self&#34;),
        )
    raise NotImplementedError(f&#34;Attribute &#39;{attr}&#39; of Dict is unknown.&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.DictType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    if attr == &#34;get&#34;:
        return InstanceType(
            FunctionType([self.key_typ, self.value_typ], self.value_typ)
        )
    if attr == &#34;keys&#34;:
        return InstanceType(FunctionType([], InstanceType(ListType(self.key_typ))))
    if attr == &#34;values&#34;:
        return InstanceType(
            FunctionType([], InstanceType(ListType(self.value_typ)))
        )
    if attr == &#34;items&#34;:
        return InstanceType(
            FunctionType(
                [],
                InstanceType(
                    ListType(InstanceType(PairType(self.key_typ, self.value_typ)))
                ),
            )
        )
    raise TypeInferenceError(
        f&#34;Type of attribute &#39;{attr}&#39; is unknown for type Dict.&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.DictType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.DictType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.DictType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.FunctionType"><code class="flex name class">
<span>class <span class="ident">FunctionType</span></span>
<span>(</span><span>argtyps: List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>], rettyp: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>FunctionType(argtyps: List[hebi.typed_ast.Type], rettyp: hebi.typed_ast.Type)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunctionType(ClassType):
    argtyps: typing.List[Type]
    rettyp: Type

    def __ge__(self, other):
        return (
            isinstance(other, FunctionType)
            and all(a &gt;= oa for a, oa in zip(self.argtyps, other.argtyps))
            and other.rettyp &gt;= self.rettyp
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.FunctionType.argtyps"><code class="name">var <span class="ident">argtyps</span> : List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.FunctionType.rettyp"><code class="name">var <span class="ident">rettyp</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.FunctionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.FunctionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.FunctionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.FunctionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.FunctionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.InaccessibleType"><code class="flex name class">
<span>class <span class="ident">InaccessibleType</span></span>
</code></dt>
<dd>
<div class="desc"><p>A type that blocks overwriting of a function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InaccessibleType(ClassType):
    &#34;&#34;&#34;A type that blocks overwriting of a function&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.InaccessibleType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.InaccessibleType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.InaccessibleType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.InaccessibleType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.InaccessibleType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.InstanceType"><code class="flex name class">
<span>class <span class="ident">InstanceType</span></span>
<span>(</span><span>typ: <a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>InstanceType(typ: hebi.typed_ast.ClassType)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InstanceType(Type):
    typ: ClassType

    def constr_type(self) -&gt; FunctionType:
        raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)

    def constr(self) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)

    def attribute_type(self, attr) -&gt; Type:
        return self.typ.attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        return self.typ.attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, InstanceType):
            return self.typ.cmp(op, o.typ)
        return super().cmp(op, o)

    def __ge__(self, other):
        return isinstance(other, InstanceType) and self.typ &gt;= other.typ</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.PolymorphicFunctionInstanceType" href="#hebi.typed_ast.PolymorphicFunctionInstanceType">PolymorphicFunctionInstanceType</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.InstanceType.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.InstanceType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.attribute" href="#hebi.typed_ast.Type.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    return self.typ.attribute(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.InstanceType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.attribute_type" href="#hebi.typed_ast.Type.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    return self.typ.attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.InstanceType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.cmp" href="#hebi.typed_ast.Type.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    if isinstance(o, InstanceType):
        return self.typ.cmp(op, o.typ)
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.InstanceType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.constr" href="#hebi.typed_ast.Type.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    raise NotImplementedError(f&#34;Can not construct an instance {self}&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.InstanceType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code>.<code><a title="hebi.typed_ast.Type.constr_type" href="#hebi.typed_ast.Type.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; FunctionType:
    raise TypeInferenceError(f&#34;Can not construct an instance {self}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.IntegerType"><code class="flex name class">
<span>class <span class="ident">IntegerType</span></span>
</code></dt>
<dd>
<div class="desc"><p>IntegerType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntegerType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(FunctionType([StringInstanceType], InstanceType(self)))

    def constr(self) -&gt; plt.AST:
        # TODO we need to strip the string implicitely before parsing it
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;],
            plt.Let(
                [
                    (&#34;e&#34;, plt.EncodeUtf8(plt.Var(&#34;x&#34;))),
                    (&#34;first_int&#34;, plt.IndexByteString(plt.Var(&#34;e&#34;), plt.Integer(0))),
                    (&#34;len&#34;, plt.LengthOfByteString(plt.Var(&#34;e&#34;))),
                    (
                        &#34;fold_start&#34;,
                        plt.Lambda(
                            [&#34;start&#34;],
                            plt.FoldList(
                                plt.Range(plt.Var(&#34;len&#34;), plt.Var(&#34;start&#34;)),
                                plt.Lambda(
                                    [&#34;s&#34;, &#34;i&#34;],
                                    plt.Let(
                                        [
                                            (
                                                &#34;b&#34;,
                                                plt.IndexByteString(
                                                    plt.Var(&#34;e&#34;), plt.Var(&#34;i&#34;)
                                                ),
                                            )
                                        ],
                                        plt.Ite(
                                            plt.EqualsInteger(
                                                plt.Var(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                            ),
                                            plt.Var(&#34;s&#34;),
                                            plt.Ite(
                                                plt.Or(
                                                    plt.LessThanInteger(
                                                        plt.Var(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.LessThanInteger(
                                                        plt.Integer(ord(&#34;9&#34;)),
                                                        plt.Var(&#34;b&#34;),
                                                    ),
                                                ),
                                                plt.TraceError(
                                                    &#34;ValueError: invalid literal for int() with base 10&#34;
                                                ),
                                                plt.AddInteger(
                                                    plt.SubtractInteger(
                                                        plt.Var(&#34;b&#34;),
                                                        plt.Integer(ord(&#34;0&#34;)),
                                                    ),
                                                    plt.MultiplyInteger(
                                                        plt.Var(&#34;s&#34;), plt.Integer(10)
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                                plt.Integer(0),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.Or(
                        plt.EqualsInteger(plt.Var(&#34;len&#34;), plt.Integer(0)),
                        plt.EqualsInteger(
                            plt.Var(&#34;first_int&#34;),
                            plt.Integer(ord(&#34;_&#34;)),
                        ),
                    ),
                    plt.TraceError(
                        &#34;ValueError: invalid literal for int() with base 10&#34;
                    ),
                    plt.Ite(
                        plt.EqualsInteger(
                            plt.Var(&#34;first_int&#34;),
                            plt.Integer(ord(&#34;-&#34;)),
                        ),
                        plt.Negate(
                            plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(1)),
                        ),
                        plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(0)),
                    ),
                ),
            ),
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        if isinstance(o, BoolType):
            if isinstance(op, Eq):
                # 1 == True
                # 0 == False
                # all other comparisons are False
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Ite(
                        plt.Var(&#34;y&#34;),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    ),
                )
        if isinstance(o, IntegerType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                            plt.Var(&#34;y&#34;),
                            plt.Var(&#34;x&#34;),
                        )
                    ),
                )
            if isinstance(op, LtE):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
            if isinstance(op, Lt):
                return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
            if isinstance(op, Gt):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
            if isinstance(op, GtE):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and isinstance(o.typ.typ, IntegerType)
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsInteger(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), plt.Var(&#34;x&#34;)
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.AddInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                        ),
                    ),
                )
        return super().cmp(op, o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.IntegerType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.IntegerType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.IntegerType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    if isinstance(o, BoolType):
        if isinstance(op, Eq):
            # 1 == True
            # 0 == False
            # all other comparisons are False
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Ite(
                    plt.Var(&#34;y&#34;),
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                ),
            )
    if isinstance(o, IntegerType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsInteger)
        if isinstance(op, NotEq):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsInteger),
                        plt.Var(&#34;y&#34;),
                        plt.Var(&#34;x&#34;),
                    )
                ),
            )
        if isinstance(op, LtE):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger)
        if isinstance(op, Lt):
            return plt.BuiltIn(uplc.BuiltInFun.LessThanInteger)
        if isinstance(op, Gt):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanInteger),
                    plt.Var(&#34;y&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            )
        if isinstance(op, GtE):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Apply(
                    plt.BuiltIn(uplc.BuiltInFun.LessThanEqualsInteger),
                    plt.Var(&#34;y&#34;),
                    plt.Var(&#34;x&#34;),
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and isinstance(o.typ.typ, IntegerType)
    ):
        if isinstance(op, In):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.EqualsInteger(
                    plt.Var(&#34;x&#34;),
                    plt.FindList(
                        plt.Var(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsInteger), plt.Var(&#34;x&#34;)
                        ),
                        # this simply ensures the default is always unequal to the searched value
                        plt.AddInteger(plt.Var(&#34;x&#34;), plt.Integer(1)),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.IntegerType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    # TODO we need to strip the string implicitely before parsing it
    return plt.Lambda(
        [&#34;_&#34;, &#34;x&#34;],
        plt.Let(
            [
                (&#34;e&#34;, plt.EncodeUtf8(plt.Var(&#34;x&#34;))),
                (&#34;first_int&#34;, plt.IndexByteString(plt.Var(&#34;e&#34;), plt.Integer(0))),
                (&#34;len&#34;, plt.LengthOfByteString(plt.Var(&#34;e&#34;))),
                (
                    &#34;fold_start&#34;,
                    plt.Lambda(
                        [&#34;start&#34;],
                        plt.FoldList(
                            plt.Range(plt.Var(&#34;len&#34;), plt.Var(&#34;start&#34;)),
                            plt.Lambda(
                                [&#34;s&#34;, &#34;i&#34;],
                                plt.Let(
                                    [
                                        (
                                            &#34;b&#34;,
                                            plt.IndexByteString(
                                                plt.Var(&#34;e&#34;), plt.Var(&#34;i&#34;)
                                            ),
                                        )
                                    ],
                                    plt.Ite(
                                        plt.EqualsInteger(
                                            plt.Var(&#34;b&#34;), plt.Integer(ord(&#34;_&#34;))
                                        ),
                                        plt.Var(&#34;s&#34;),
                                        plt.Ite(
                                            plt.Or(
                                                plt.LessThanInteger(
                                                    plt.Var(&#34;b&#34;),
                                                    plt.Integer(ord(&#34;0&#34;)),
                                                ),
                                                plt.LessThanInteger(
                                                    plt.Integer(ord(&#34;9&#34;)),
                                                    plt.Var(&#34;b&#34;),
                                                ),
                                            ),
                                            plt.TraceError(
                                                &#34;ValueError: invalid literal for int() with base 10&#34;
                                            ),
                                            plt.AddInteger(
                                                plt.SubtractInteger(
                                                    plt.Var(&#34;b&#34;),
                                                    plt.Integer(ord(&#34;0&#34;)),
                                                ),
                                                plt.MultiplyInteger(
                                                    plt.Var(&#34;s&#34;), plt.Integer(10)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                            plt.Integer(0),
                        ),
                    ),
                ),
            ],
            plt.Ite(
                plt.Or(
                    plt.EqualsInteger(plt.Var(&#34;len&#34;), plt.Integer(0)),
                    plt.EqualsInteger(
                        plt.Var(&#34;first_int&#34;),
                        plt.Integer(ord(&#34;_&#34;)),
                    ),
                ),
                plt.TraceError(
                    &#34;ValueError: invalid literal for int() with base 10&#34;
                ),
                plt.Ite(
                    plt.EqualsInteger(
                        plt.Var(&#34;first_int&#34;),
                        plt.Integer(ord(&#34;-&#34;)),
                    ),
                    plt.Negate(
                        plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(1)),
                    ),
                    plt.Apply(plt.Var(&#34;fold_start&#34;), plt.Integer(0)),
                ),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.IntegerType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(FunctionType([StringInstanceType], InstanceType(self)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.ListType"><code class="flex name class">
<span>class <span class="ident">ListType</span></span>
<span>(</span><span>typ: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>ListType(typ: hebi.typed_ast.Type)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListType(ClassType):
    typ: Type

    def __ge__(self, other):
        return isinstance(other, ListType) and self.typ &gt;= other.typ</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.ListType.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.ListType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.ListType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.ListType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.ListType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.ListType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.PairType"><code class="flex name class">
<span>class <span class="ident">PairType</span></span>
<span>(</span><span>l_typ: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>, r_typ: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal type representing built-in PlutusData pairs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PairType(ClassType):
    &#34;&#34;&#34;An internal type representing built-in PlutusData pairs&#34;&#34;&#34;

    l_typ: Type
    r_typ: Type

    def __ge__(self, other):
        return isinstance(other, PairType) and all(
            t &gt;= ot
            for t, ot in zip((self.l_typ, self.r_typ), (other.l_typ, other.r_typ))
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.PairType.l_typ"><code class="name">var <span class="ident">l_typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.PairType.r_typ"><code class="name">var <span class="ident">r_typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.PairType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.PairType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.PairType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.PairType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.PairType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunction"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunction</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolymorphicFunction:
    def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
        raise NotImplementedError()

    def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.util.LenImpl" href="util.html#hebi.util.LenImpl">LenImpl</a></li>
<li><a title="hebi.util.ReversedImpl" href="util.html#hebi.util.ReversedImpl">ReversedImpl</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.PolymorphicFunction.impl_from_args"><code class="name flex">
<span>def <span class="ident">impl_from_args</span></span>(<span>self, args: List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impl_from_args(self, args: typing.List[Type]) -&gt; plt.AST:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunction.type_from_args"><code class="name flex">
<span>def <span class="ident">type_from_args</span></span>(<span>self, args: List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]) ‑> <a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_from_args(self, args: typing.List[Type]) -&gt; FunctionType:
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunctionInstanceType</span></span>
<span>(</span><span>typ: <a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a>, polymorphic_function: <a title="hebi.typed_ast.PolymorphicFunction" href="#hebi.typed_ast.PolymorphicFunction">PolymorphicFunction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>PolymorphicFunctionInstanceType(typ: hebi.typed_ast.FunctionType, polymorphic_function: hebi.typed_ast.PolymorphicFunction)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolymorphicFunctionInstanceType(InstanceType):
    typ: FunctionType
    polymorphic_function: PolymorphicFunction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.polymorphic_function"><code class="name">var <span class="ident">polymorphic_function</span> : <a title="hebi.typed_ast.PolymorphicFunction" href="#hebi.typed_ast.PolymorphicFunction">PolymorphicFunction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code>.<code><a title="hebi.typed_ast.InstanceType.attribute" href="#hebi.typed_ast.InstanceType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code>.<code><a title="hebi.typed_ast.InstanceType.attribute_type" href="#hebi.typed_ast.InstanceType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code>.<code><a title="hebi.typed_ast.InstanceType.cmp" href="#hebi.typed_ast.InstanceType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code>.<code><a title="hebi.typed_ast.InstanceType.constr" href="#hebi.typed_ast.InstanceType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionInstanceType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code>.<code><a title="hebi.typed_ast.InstanceType.constr_type" href="#hebi.typed_ast.InstanceType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionType"><code class="flex name class">
<span>class <span class="ident">PolymorphicFunctionType</span></span>
<span>(</span><span>polymorphic_function: <a title="hebi.typed_ast.PolymorphicFunction" href="#hebi.typed_ast.PolymorphicFunction">PolymorphicFunction</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A special type of builtin that may act differently on different parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolymorphicFunctionType(ClassType):
    &#34;&#34;&#34;A special type of builtin that may act differently on different parameters&#34;&#34;&#34;

    polymorphic_function: PolymorphicFunction</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.PolymorphicFunctionType.polymorphic_function"><code class="name">var <span class="ident">polymorphic_function</span> : <a title="hebi.typed_ast.PolymorphicFunction" href="#hebi.typed_ast.PolymorphicFunction">PolymorphicFunction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.PolymorphicFunctionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.PolymorphicFunctionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.RawPlutoExpr"><code class="flex name class">
<span>class <span class="ident">RawPlutoExpr</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawPlutoExpr(typedexpr):
    typ: Type
    expr: plt.AST</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.RawPlutoExpr.expr"><code class="name">var <span class="ident">expr</span> : pluthon.pluthon_ast.AST</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.RawPlutoExpr.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.Record"><code class="flex name class">
<span>class <span class="ident">Record</span></span>
<span>(</span><span>name: str, constructor: int, fields: Union[List[Tuple[str, <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]], frozenlist._frozenlist.FrozenList])</span>
</code></dt>
<dd>
<div class="desc"><p>Record(name: str, constructor: int, fields: Union[List[Tuple[str, hebi.typed_ast.Type]], frozenlist._frozenlist.FrozenList])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Record:
    name: str
    constructor: int
    fields: typing.Union[typing.List[typing.Tuple[str, Type]], FrozenList]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.Record.constructor"><code class="name">var <span class="ident">constructor</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.Record.fields"><code class="name">var <span class="ident">fields</span> : Union[List[Tuple[str, <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]], frozenlist._frozenlist.FrozenList]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.Record.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.RecordType"><code class="flex name class">
<span>class <span class="ident">RecordType</span></span>
<span>(</span><span>record: <a title="hebi.typed_ast.Record" href="#hebi.typed_ast.Record">Record</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>RecordType(record: hebi.typed_ast.Record)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordType(ClassType):
    record: Record

    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        return InstanceType(
            FunctionType([f[1] for f in self.record.fields], InstanceType(self))
        )

    def constr(self) -&gt; plt.AST:
        # wrap all constructor values to PlutusData
        build_constr_params = plt.EmptyDataList()
        for n, t in reversed(self.record.fields):
            build_constr_params = plt.MkCons(
                transform_output_map(t)(plt.Var(n)), build_constr_params
            )
        # then build a constr type with this PlutusData
        return plt.Lambda(
            [&#34;_&#34;] + [n for n, _ in self.record.fields],
            plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
        )

    def attribute_type(self, attr: str) -&gt; Type:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        for n, t in self.record.fields:
            if n == attr:
                return t
        raise TypeInferenceError(
            f&#34;Type {self.record.name} does not have attribute {attr}&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return plt.Lambda(
                [&#34;self&#34;],
                plt.Constructor(plt.Var(&#34;self&#34;)),
            )
        attr_typ = self.attribute_type(attr)
        pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
        # access to normal fields
        return plt.Lambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.NthField(
                    plt.Var(&#34;self&#34;),
                    plt.Integer(pos),
                ),
            ),
        )

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        if (isinstance(o, RecordType) and o.record == self.record) or (
            isinstance(o, UnionType) and self in o.typs
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            plt.Var(&#34;x&#34;),
                            plt.Var(&#34;y&#34;),
                        )
                    ),
                )
        if (
            isinstance(o, ListType)
            and isinstance(o.typ, InstanceType)
            and o.typ.typ &gt;= self
        ):
            if isinstance(op, In):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.EqualsData(
                        plt.Var(&#34;x&#34;),
                        plt.FindList(
                            plt.Var(&#34;y&#34;),
                            plt.Apply(
                                plt.BuiltIn(uplc.BuiltInFun.EqualsData), plt.Var(&#34;x&#34;)
                            ),
                            # this simply ensures the default is always unequal to the searched value
                            plt.ConstrData(
                                plt.AddInteger(
                                    plt.Constructor(plt.Var(&#34;x&#34;)), plt.Integer(1)
                                ),
                                plt.MkNilData(plt.Unit()),
                            ),
                        ),
                    ),
                )
        return super().cmp(op, o)

    def __ge__(self, other):
        # Can only substitute for its own type, records need to be equal
        # if someone wants to be funny, they can implement &lt;= to be true if all fields match up to some point
        return isinstance(other, self.__class__) and other.record == self.record</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.RecordType.record"><code class="name">var <span class="ident">record</span> : <a title="hebi.typed_ast.Record" href="#hebi.typed_ast.Record">Record</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.RecordType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr: str) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The attributes of this class. Need to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr: str) -&gt; plt.AST:
    &#34;&#34;&#34;The attributes of this class. Need to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        # access to constructor
        return plt.Lambda(
            [&#34;self&#34;],
            plt.Constructor(plt.Var(&#34;self&#34;)),
        )
    attr_typ = self.attribute_type(attr)
    pos = next(i for i, (n, _) in enumerate(self.record.fields) if n == attr)
    # access to normal fields
    return plt.Lambda(
        [&#34;self&#34;],
        transform_ext_params_map(attr_typ)(
            plt.NthField(
                plt.Var(&#34;self&#34;),
                plt.Integer(pos),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.RecordType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr: str) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr: str) -&gt; Type:
    &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
    if attr == &#34;CONSTR_ID&#34;:
        return IntegerInstanceType
    for n, t in self.record.fields:
        if n == attr:
            return t
    raise TypeInferenceError(
        f&#34;Type {self.record.name} does not have attribute {attr}&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.RecordType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    # this will reject comparisons that will always be false - most likely due to faults during programming
    if (isinstance(o, RecordType) and o.record == self.record) or (
        isinstance(o, UnionType) and self in o.typs
    ):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
        if isinstance(op, NotEq):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        plt.Var(&#34;x&#34;),
                        plt.Var(&#34;y&#34;),
                    )
                ),
            )
    if (
        isinstance(o, ListType)
        and isinstance(o.typ, InstanceType)
        and o.typ.typ &gt;= self
    ):
        if isinstance(op, In):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.EqualsData(
                    plt.Var(&#34;x&#34;),
                    plt.FindList(
                        plt.Var(&#34;y&#34;),
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData), plt.Var(&#34;x&#34;)
                        ),
                        # this simply ensures the default is always unequal to the searched value
                        plt.ConstrData(
                            plt.AddInteger(
                                plt.Constructor(plt.Var(&#34;x&#34;)), plt.Integer(1)
                            ),
                            plt.MkNilData(plt.Unit()),
                        ),
                    ),
                ),
            )
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.RecordType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    # wrap all constructor values to PlutusData
    build_constr_params = plt.EmptyDataList()
    for n, t in reversed(self.record.fields):
        build_constr_params = plt.MkCons(
            transform_output_map(t)(plt.Var(n)), build_constr_params
        )
    # then build a constr type with this PlutusData
    return plt.Lambda(
        [&#34;_&#34;] + [n for n, _ in self.record.fields],
        plt.ConstrData(plt.Integer(self.record.constructor), build_constr_params),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.RecordType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    return InstanceType(
        FunctionType([f[1] for f in self.record.fields], InstanceType(self))
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.StringType"><code class="flex name class">
<span>class <span class="ident">StringType</span></span>
</code></dt>
<dd>
<div class="desc"><p>StringType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringType(AtomicType):
    def constr_type(self) -&gt; InstanceType:
        return InstanceType(FunctionType([IntegerInstanceType], InstanceType(self)))

    def constr(self) -&gt; plt.AST:
        # constructs a string representation of an integer
        return plt.Lambda(
            [&#34;_&#34;, &#34;x&#34;],
            plt.DecodeUtf8(
                plt.Let(
                    [
                        (
                            &#34;strlist&#34;,
                            plt.RecFun(
                                plt.Lambda(
                                    [&#34;f&#34;, &#34;i&#34;],
                                    plt.Ite(
                                        plt.LessThanEqualsInteger(
                                            plt.Var(&#34;i&#34;), plt.Integer(0)
                                        ),
                                        plt.EmptyIntegerList(),
                                        plt.MkCons(
                                            plt.AddInteger(
                                                plt.ModInteger(
                                                    plt.Var(&#34;i&#34;), plt.Integer(10)
                                                ),
                                                plt.Integer(ord(&#34;0&#34;)),
                                            ),
                                            plt.Apply(
                                                plt.Var(&#34;f&#34;),
                                                plt.Var(&#34;f&#34;),
                                                plt.DivideInteger(
                                                    plt.Var(&#34;i&#34;), plt.Integer(10)
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                        (
                            &#34;mkstr&#34;,
                            plt.Lambda(
                                [&#34;i&#34;],
                                plt.FoldList(
                                    plt.Apply(plt.Var(&#34;strlist&#34;), plt.Var(&#34;i&#34;)),
                                    plt.Lambda(
                                        [&#34;b&#34;, &#34;i&#34;],
                                        plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                    ),
                                    plt.ByteString(b&#34;&#34;),
                                ),
                            ),
                        ),
                    ],
                    plt.Ite(
                        plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ByteString(b&#34;0&#34;),
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                            plt.ConsByteString(
                                plt.Integer(ord(&#34;-&#34;)),
                                plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                            ),
                            plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Var(&#34;x&#34;)),
                        ),
                    ),
                )
            ),
        )

    def attribute_type(self, attr) -&gt; Type:
        if attr == &#34;encode&#34;:
            return InstanceType(FunctionType([], ByteStringInstanceType))
        return super().attribute_type(attr)

    def attribute(self, attr) -&gt; plt.AST:
        if attr == &#34;encode&#34;:
            # No codec -&gt; only the default (utf8) is allowed
            return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(plt.Var(&#34;x&#34;)))
        return super().attribute(attr)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, StringType):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
        return super().cmp(op, o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.StringType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    if attr == &#34;encode&#34;:
        # No codec -&gt; only the default (utf8) is allowed
        return plt.Lambda([&#34;x&#34;, &#34;_&#34;], plt.EncodeUtf8(plt.Var(&#34;x&#34;)))
    return super().attribute(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.StringType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; Type:
    if attr == &#34;encode&#34;:
        return InstanceType(FunctionType([], ByteStringInstanceType))
    return super().attribute_type(attr)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.StringType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, StringType):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsString)
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.StringType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    # constructs a string representation of an integer
    return plt.Lambda(
        [&#34;_&#34;, &#34;x&#34;],
        plt.DecodeUtf8(
            plt.Let(
                [
                    (
                        &#34;strlist&#34;,
                        plt.RecFun(
                            plt.Lambda(
                                [&#34;f&#34;, &#34;i&#34;],
                                plt.Ite(
                                    plt.LessThanEqualsInteger(
                                        plt.Var(&#34;i&#34;), plt.Integer(0)
                                    ),
                                    plt.EmptyIntegerList(),
                                    plt.MkCons(
                                        plt.AddInteger(
                                            plt.ModInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(10)
                                            ),
                                            plt.Integer(ord(&#34;0&#34;)),
                                        ),
                                        plt.Apply(
                                            plt.Var(&#34;f&#34;),
                                            plt.Var(&#34;f&#34;),
                                            plt.DivideInteger(
                                                plt.Var(&#34;i&#34;), plt.Integer(10)
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                    (
                        &#34;mkstr&#34;,
                        plt.Lambda(
                            [&#34;i&#34;],
                            plt.FoldList(
                                plt.Apply(plt.Var(&#34;strlist&#34;), plt.Var(&#34;i&#34;)),
                                plt.Lambda(
                                    [&#34;b&#34;, &#34;i&#34;],
                                    plt.ConsByteString(plt.Var(&#34;i&#34;), plt.Var(&#34;b&#34;)),
                                ),
                                plt.ByteString(b&#34;&#34;),
                            ),
                        ),
                    ),
                ],
                plt.Ite(
                    plt.EqualsInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                    plt.ByteString(b&#34;0&#34;),
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;x&#34;), plt.Integer(0)),
                        plt.ConsByteString(
                            plt.Integer(ord(&#34;-&#34;)),
                            plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Negate(plt.Var(&#34;x&#34;))),
                        ),
                        plt.Apply(plt.Var(&#34;mkstr&#34;), plt.Var(&#34;x&#34;)),
                    ),
                ),
            )
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.StringType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; InstanceType:
    return InstanceType(FunctionType([IntegerInstanceType], InstanceType(self)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TupleType"><code class="flex name class">
<span>class <span class="ident">TupleType</span></span>
<span>(</span><span>typs: List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>TupleType(typs: List[hebi.typed_ast.Type])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TupleType(ClassType):
    typs: typing.List[Type]

    def __ge__(self, other):
        return isinstance(other, TupleType) and all(
            t &gt;= ot for t, ot in zip(self.typs, other.typs)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TupleType.typs"><code class="name">var <span class="ident">typs</span> : List[<a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.TupleType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.TupleType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.TupleType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
</dd>
<dt id="hebi.typed_ast.TupleType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.TupleType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.Type"><code class="flex name class">
<span>class <span class="ident">Type</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Type:
    def constr_type(self) -&gt; &#34;InstanceType&#34;:
        &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have a constructor&#34;
        )

    def constr(self) -&gt; plt.AST:
        &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Constructor of {self.__class__} not implemented&#34;)

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
        raise TypeInferenceError(
            f&#34;Object of type {self.__class__} does not have attribute {attr}&#34;
        )

    def attribute(self, attr) -&gt; plt.AST:
        &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
        raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.Type.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr) -&gt; plt.AST:
    &#34;&#34;&#34;The attributes of this class. Needs to be a lambda that expects as first argument the object itself&#34;&#34;&#34;
    raise NotImplementedError(f&#34;Attribute {attr} not implemented for type {self}&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.Type.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<div class="desc"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    &#34;&#34;&#34;The types of the named attributes of this class&#34;&#34;&#34;
    raise TypeInferenceError(
        f&#34;Object of type {self.__class__} does not have attribute {attr}&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.Type.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Comparison {type(op).__name__} for {self.__class__.__name__} and {o.__class__.__name__} is not implemented. This is likely intended because it would always evaluate to False.&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.Type.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>The constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr(self) -&gt; plt.AST:
    &#34;&#34;&#34;The constructor for this class&#34;&#34;&#34;
    raise NotImplementedError(f&#34;Constructor of {self.__class__} not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.Type.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<div class="desc"><p>The type of the constructor for this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constr_type(self) -&gt; &#34;InstanceType&#34;:
    &#34;&#34;&#34;The type of the constructor for this class&#34;&#34;&#34;
    raise TypeInferenceError(
        f&#34;Object of type {self.__class__} does not have a constructor&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypeInferenceError"><code class="flex name class">
<span>class <span class="ident">TypeInferenceError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Assertion failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeInferenceError(AssertionError):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.AssertionError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="hebi.typed_ast.TypedAST"><code class="flex name class">
<span>class <span class="ident">TypedAST</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedAST(AST):
    typ: Type</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_ast.AST</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedConstant" href="#hebi.typed_ast.TypedConstant">TypedConstant</a></li>
<li><a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a></li>
<li><a title="hebi.typed_ast.typedarguments" href="#hebi.typed_ast.typedarguments">typedarguments</a></li>
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedAST.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedAnnAssign"><code class="flex name class">
<span>class <span class="ident">TypedAnnAssign</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedAnnAssign(typedstmt, AnnAssign):
    target: typedexpr
    annotation: Type
    value: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.AnnAssign</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedAnnAssign.annotation"><code class="name">var <span class="ident">annotation</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedAnnAssign.target"><code class="name">var <span class="ident">target</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedAnnAssign.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedAssert"><code class="flex name class">
<span>class <span class="ident">TypedAssert</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedAssert(typedstmt, Assert):
    test: typedexpr
    msg: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Assert</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedAssert.msg"><code class="name">var <span class="ident">msg</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedAssert.test"><code class="name">var <span class="ident">test</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedAssign"><code class="flex name class">
<span>class <span class="ident">TypedAssign</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedAssign(typedstmt, Assign):
    targets: typing.List[typedexpr]
    value: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Assign</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedAssign.targets"><code class="name">var <span class="ident">targets</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedAssign.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedAttribute"><code class="flex name class">
<span>class <span class="ident">TypedAttribute</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedAttribute(typedexpr, Attribute):
    value: typedexpr
    pos: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Attribute</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedAttribute.pos"><code class="name">var <span class="ident">pos</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedAttribute.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedBinOp"><code class="flex name class">
<span>class <span class="ident">TypedBinOp</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedBinOp(typedexpr, BinOp):
    left: typedexpr
    right: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.BinOp</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedBinOp.left"><code class="name">var <span class="ident">left</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedBinOp.right"><code class="name">var <span class="ident">right</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedBoolOp"><code class="flex name class">
<span>class <span class="ident">TypedBoolOp</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedBoolOp(typedexpr, BoolOp):
    values: typing.List[typedexpr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.BoolOp</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedBoolOp.values"><code class="name">var <span class="ident">values</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedCall"><code class="flex name class">
<span>class <span class="ident">TypedCall</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedCall(typedexpr, Call):
    func: typedexpr
    args: typing.List[typedexpr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Call</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedCall.args"><code class="name">var <span class="ident">args</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedCall.func"><code class="name">var <span class="ident">func</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedClassDef"><code class="flex name class">
<span>class <span class="ident">TypedClassDef</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedClassDef(typedstmt, ClassDef):
    class_typ: Type</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.ClassDef</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedClassDef.class_typ"><code class="name">var <span class="ident">class_typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedCompare"><code class="flex name class">
<span>class <span class="ident">TypedCompare</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedCompare(typedexpr, Compare):
    left: typedexpr
    ops: typing.List[cmpop]
    comparators: typing.List[typedexpr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Compare</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedCompare.comparators"><code class="name">var <span class="ident">comparators</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedCompare.left"><code class="name">var <span class="ident">left</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedCompare.ops"><code class="name">var <span class="ident">ops</span> : List[_ast.cmpop]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedConstant"><code class="flex name class">
<span>class <span class="ident">TypedConstant</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedConstant(TypedAST, Constant):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Constant</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedConstant.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedDict"><code class="flex name class">
<span>class <span class="ident">TypedDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedDict(typedexpr, Dict):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Dict</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedDict.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedExpr"><code class="flex name class">
<span>class <span class="ident">TypedExpr</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedExpr(typedstmt, Expr):
    value: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Expr</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedExpr.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedExpression"><code class="flex name class">
<span>class <span class="ident">TypedExpression</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedExpression(typedexpr, Expression):
    body: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.expr</li>
<li>_ast.Expression</li>
<li>_ast.mod</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedExpression.body"><code class="name">var <span class="ident">body</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedFor"><code class="flex name class">
<span>class <span class="ident">TypedFor</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedFor(typedstmt, For):
    target: typedexpr
    iter: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.For</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedFor.body"><code class="name">var <span class="ident">body</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedFor.iter"><code class="name">var <span class="ident">iter</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedFor.orelse"><code class="name">var <span class="ident">orelse</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedFor.target"><code class="name">var <span class="ident">target</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedFunctionDef"><code class="flex name class">
<span>class <span class="ident">TypedFunctionDef</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedFunctionDef(typedstmt, FunctionDef):
    body: typing.List[typedstmt]
    args: arguments</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.FunctionDef</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedFunctionDef.args"><code class="name">var <span class="ident">args</span> : _ast.arguments</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedFunctionDef.body"><code class="name">var <span class="ident">body</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedIf"><code class="flex name class">
<span>class <span class="ident">TypedIf</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedIf(typedstmt, If):
    test: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.If</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedIf.body"><code class="name">var <span class="ident">body</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedIf.orelse"><code class="name">var <span class="ident">orelse</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedIf.test"><code class="name">var <span class="ident">test</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedIfExp"><code class="flex name class">
<span>class <span class="ident">TypedIfExp</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedIfExp(typedstmt, IfExp):
    test: typedexpr
    body: typedexpr
    orelse: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.stmt</li>
<li>_ast.IfExp</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedIfExp.body"><code class="name">var <span class="ident">body</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedIfExp.orelse"><code class="name">var <span class="ident">orelse</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedIfExp.test"><code class="name">var <span class="ident">test</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedList"><code class="flex name class">
<span>class <span class="ident">TypedList</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedList(typedexpr, List):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.List</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedList.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedListComp"><code class="flex name class">
<span>class <span class="ident">TypedListComp</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedListComp(typedexpr, ListComp):
    generators: typing.List[typedcomprehension]
    elt: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.ListComp</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedListComp.elt"><code class="name">var <span class="ident">elt</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedListComp.generators"><code class="name">var <span class="ident">generators</span> : List[<a title="hebi.typed_ast.typedcomprehension" href="#hebi.typed_ast.typedcomprehension">typedcomprehension</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedModule"><code class="flex name class">
<span>class <span class="ident">TypedModule</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedModule(typedstmt, Module):
    body: typing.List[typedstmt]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.stmt</li>
<li>_ast.Module</li>
<li>_ast.mod</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedModule.body"><code class="name">var <span class="ident">body</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedName"><code class="flex name class">
<span>class <span class="ident">TypedName</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedName(typedexpr, Name):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Name</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedName.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedNodeTransformer"><code class="flex name class">
<span>class <span class="ident">TypedNodeTransformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Index(value=Str(s=node.id)),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedNodeTransformer(NodeTransformer):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeTransformer" href="util.html#hebi.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.TypedNodeTransformer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
    node_class_name = node.__class__.__name__
    if node_class_name.startswith(&#34;Typed&#34;):
        node_class_name = node_class_name[len(&#34;Typed&#34;) :]
    method = &#34;visit_&#34; + node_class_name
    visitor = getattr(self, method, self.generic_visit)
    return visitor(node)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedNodeVisitor"><code class="flex name class">
<span>class <span class="ident">TypedNodeVisitor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedNodeVisitor(NodeVisitor):
    def visit(self, node):
        &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
        node_class_name = node.__class__.__name__
        if node_class_name.startswith(&#34;Typed&#34;):
            node_class_name = node_class_name[len(&#34;Typed&#34;) :]
        method = &#34;visit_&#34; + node_class_name
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeVisitor" href="util.html#hebi.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.TypedNodeVisitor.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Visit a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, node):
    &#34;&#34;&#34;Visit a node.&#34;&#34;&#34;
    node_class_name = node.__class__.__name__
    if node_class_name.startswith(&#34;Typed&#34;):
        node_class_name = node_class_name[len(&#34;Typed&#34;) :]
    method = &#34;visit_&#34; + node_class_name
    visitor = getattr(self, method, self.generic_visit)
    return visitor(node)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedPass"><code class="flex name class">
<span>class <span class="ident">TypedPass</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedPass(typedstmt, Pass):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Pass</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedPass.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedReturn"><code class="flex name class">
<span>class <span class="ident">TypedReturn</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedReturn(typedstmt, Return):
    value: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Return</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedReturn.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedSubscript"><code class="flex name class">
<span>class <span class="ident">TypedSubscript</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedSubscript(typedexpr, Subscript):
    value: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Subscript</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedSubscript.value"><code class="name">var <span class="ident">value</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedTuple"><code class="flex name class">
<span>class <span class="ident">TypedTuple</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedTuple(typedexpr, Tuple):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.Tuple</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedTuple.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedUnaryOp"><code class="flex name class">
<span>class <span class="ident">TypedUnaryOp</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedUnaryOp(typedexpr, UnaryOp):
    operand: typedexpr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.UnaryOp</li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedUnaryOp.operand"><code class="name">var <span class="ident">operand</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.TypedWhile"><code class="flex name class">
<span>class <span class="ident">TypedWhile</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypedWhile(typedstmt, While):
    test: typedexpr
    body: typing.List[typedstmt]
    orelse: typing.List[typedstmt]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.While</li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.TypedWhile.body"><code class="name">var <span class="ident">body</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedWhile.orelse"><code class="name">var <span class="ident">orelse</span> : List[<a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.TypedWhile.test"><code class="name">var <span class="ident">test</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.UnionType"><code class="flex name class">
<span>class <span class="ident">UnionType</span></span>
<span>(</span><span>typs: List[<a title="hebi.typed_ast.RecordType" href="#hebi.typed_ast.RecordType">RecordType</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>UnionType(typs: List[hebi.typed_ast.RecordType])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnionType(ClassType):
    typs: typing.List[RecordType]

    def attribute_type(self, attr) -&gt; &#34;Type&#34;:
        if attr == &#34;CONSTR_ID&#34;:
            return IntegerInstanceType
        # iterate through all names/types of the unioned records by position
        for attr_names, attr_types in map(
            lambda x: zip(*x), zip(*(t.record.fields for t in self.typs))
        ):
            # need to have a common field with the same name, in the same position!
            if any(attr_name != attr for attr_name in attr_names):
                continue
            for at in attr_types:
                # return the maximum element if there is one
                if all(at &gt;= at2 for at2 in attr_types):
                    return at
            # return the union type of all possible instantiations if all possible values are record types
            if all(
                isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
                for at in attr_types
            ) and distinct([at.typ.record.constructor for at in attr_types]):
                return InstanceType(
                    UnionType(FrozenFrozenList([at.typ for at in attr_types]))
                )
            # return Anytype
            return InstanceType(AnyType())
        raise TypeInferenceError(
            f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
        )

    def attribute(self, attr: str) -&gt; plt.AST:
        if attr == &#34;CONSTR_ID&#34;:
            # access to constructor
            return plt.Lambda(
                [&#34;self&#34;],
                plt.Constructor(plt.Var(&#34;self&#34;)),
            )
        # iterate through all names/types of the unioned records by position
        attr_typ = self.attribute_type(attr)
        pos = next(
            i
            for i, (ns, _) in enumerate(
                map(lambda x: zip(*x), zip(*(t.record.fields for t in self.typs)))
            )
            if all(n == attr for n in ns)
        )
        # access to normal fields
        return plt.Lambda(
            [&#34;self&#34;],
            transform_ext_params_map(attr_typ)(
                plt.NthField(
                    plt.Var(&#34;self&#34;),
                    plt.Integer(pos),
                ),
            ),
        )

    def __ge__(self, other):
        if isinstance(other, UnionType):
            return all(any(t &gt;= ot for ot in other.typs) for t in self.typs)
        return any(t &gt;= other for t in self.typs)

    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
        # this will reject comparisons that will always be false - most likely due to faults during programming
        # note we require that there is an overlapt between the possible types for unions
        if (isinstance(o, RecordType) and o in self.typs) or (
            isinstance(o, UnionType) and set(self.typs).intersection(o.typs)
        ):
            if isinstance(op, Eq):
                return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
            if isinstance(op, NotEq):
                return plt.Lambda(
                    [&#34;x&#34;, &#34;y&#34;],
                    plt.Not(
                        plt.Apply(
                            plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                            plt.Var(&#34;x&#34;),
                            plt.Var(&#34;y&#34;),
                        )
                    ),
                )
        raise NotImplementedError(
            f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.UnionType.typs"><code class="name">var <span class="ident">typs</span> : List[<a title="hebi.typed_ast.RecordType" href="#hebi.typed_ast.RecordType">RecordType</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.UnionType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr: str) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute(self, attr: str) -&gt; plt.AST:
    if attr == &#34;CONSTR_ID&#34;:
        # access to constructor
        return plt.Lambda(
            [&#34;self&#34;],
            plt.Constructor(plt.Var(&#34;self&#34;)),
        )
    # iterate through all names/types of the unioned records by position
    attr_typ = self.attribute_type(attr)
    pos = next(
        i
        for i, (ns, _) in enumerate(
            map(lambda x: zip(*x), zip(*(t.record.fields for t in self.typs)))
        )
        if all(n == attr for n in ns)
    )
    # access to normal fields
    return plt.Lambda(
        [&#34;self&#34;],
        transform_ext_params_map(attr_typ)(
            plt.NthField(
                plt.Var(&#34;self&#34;),
                plt.Integer(pos),
            ),
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.UnionType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attribute_type(self, attr) -&gt; &#34;Type&#34;:
    if attr == &#34;CONSTR_ID&#34;:
        return IntegerInstanceType
    # iterate through all names/types of the unioned records by position
    for attr_names, attr_types in map(
        lambda x: zip(*x), zip(*(t.record.fields for t in self.typs))
    ):
        # need to have a common field with the same name, in the same position!
        if any(attr_name != attr for attr_name in attr_names):
            continue
        for at in attr_types:
            # return the maximum element if there is one
            if all(at &gt;= at2 for at2 in attr_types):
                return at
        # return the union type of all possible instantiations if all possible values are record types
        if all(
            isinstance(at, InstanceType) and isinstance(at.typ, RecordType)
            for at in attr_types
        ) and distinct([at.typ.record.constructor for at in attr_types]):
            return InstanceType(
                UnionType(FrozenFrozenList([at.typ for at in attr_types]))
            )
        # return Anytype
        return InstanceType(AnyType())
    raise TypeInferenceError(
        f&#34;Can not access attribute {attr} of Union type. Cast to desired type with an &#39;if isinstance(_, _):&#39; branch.&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.UnionType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    &#34;&#34;&#34;The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.&#34;&#34;&#34;
    # this will reject comparisons that will always be false - most likely due to faults during programming
    # note we require that there is an overlapt between the possible types for unions
    if (isinstance(o, RecordType) and o in self.typs) or (
        isinstance(o, UnionType) and set(self.typs).intersection(o.typs)
    ):
        if isinstance(op, Eq):
            return plt.BuiltIn(uplc.BuiltInFun.EqualsData)
        if isinstance(op, NotEq):
            return plt.Lambda(
                [&#34;x&#34;, &#34;y&#34;],
                plt.Not(
                    plt.Apply(
                        plt.BuiltIn(uplc.BuiltInFun.EqualsData),
                        plt.Var(&#34;x&#34;),
                        plt.Var(&#34;y&#34;),
                    )
                ),
            )
    raise NotImplementedError(
        f&#34;Can not compare {o} and {self} with operation {op.__class__}. Note that comparisons that always return false are also rejected.&#34;
    )</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.UnionType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.UnionType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code>.<code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.UnitType"><code class="flex name class">
<span>class <span class="ident">UnitType</span></span>
</code></dt>
<dd>
<div class="desc"><p>UnitType()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitType(AtomicType):
    def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
        if isinstance(o, UnitType):
            if isinstance(op, Eq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
            if isinstance(op, NotEq):
                return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
        return super().cmp(op, o)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></li>
<li><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></li>
<li><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="hebi.typed_ast.UnitType.attribute"><code class="name flex">
<span>def <span class="ident">attribute</span></span>(<span>self, attr) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code>
</p>
<div class="desc inherited"><p>The attributes of this class. Needs to be a lambda that expects as first argument the object itself</p></div>
</dd>
<dt id="hebi.typed_ast.UnitType.attribute_type"><code class="name flex">
<span>def <span class="ident">attribute_type</span></span>(<span>self, attr) ‑> <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code>
</p>
<div class="desc inherited"><p>The types of the named attributes of this class</p></div>
</dd>
<dt id="hebi.typed_ast.UnitType.cmp"><code class="name flex">
<span>def <span class="ident">cmp</span></span>(<span>self, op: _ast.cmpop, o: <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code>
</p>
<div class="desc inherited"><p>The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmp(self, op: cmpop, o: &#34;Type&#34;) -&gt; plt.AST:
    if isinstance(o, UnitType):
        if isinstance(op, Eq):
            return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(True))
        if isinstance(op, NotEq):
            return plt.Lambda([&#34;x&#34;, &#34;y&#34;], plt.Bool(False))
    return super().cmp(op, o)</code></pre>
</details>
</dd>
<dt id="hebi.typed_ast.UnitType.constr"><code class="name flex">
<span>def <span class="ident">constr</span></span>(<span>self) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code>
</p>
<div class="desc inherited"><p>The constructor for this class</p></div>
</dd>
<dt id="hebi.typed_ast.UnitType.constr_type"><code class="name flex">
<span>def <span class="ident">constr_type</span></span>(<span>self) ‑> <a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code>.<code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code>
</p>
<div class="desc inherited"><p>The type of the constructor for this class</p></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.typedarg"><code class="flex name class">
<span>class <span class="ident">typedarg</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class typedarg(TypedAST, arg):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.arg</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.typedarg.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.typedarguments"><code class="flex name class">
<span>class <span class="ident">typedarguments</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class typedarguments(TypedAST, arguments):
    args: typing.List[typedarg]
    vararg: typing.Union[typedarg, None]
    kwonlyargs: typing.List[typedarg]
    kw_defaults: typing.List[typing.Union[typedexpr, None]]
    kwarg: typing.Union[typedarg, None]
    defaults: typing.List[typedexpr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.arguments</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.typedarguments.args"><code class="name">var <span class="ident">args</span> : List[<a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedarguments.defaults"><code class="name">var <span class="ident">defaults</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedarguments.kw_defaults"><code class="name">var <span class="ident">kw_defaults</span> : List[Optional[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedarguments.kwarg"><code class="name">var <span class="ident">kwarg</span> : Optional[<a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedarguments.kwonlyargs"><code class="name">var <span class="ident">kwonlyargs</span> : List[<a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedarguments.vararg"><code class="name">var <span class="ident">vararg</span> : Optional[<a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.typedcomprehension"><code class="flex name class">
<span>class <span class="ident">typedcomprehension</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class typedcomprehension(typedexpr, comprehension):
    target: typedexpr
    iter: typedexpr
    ifs: typing.List[typedexpr]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></li>
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.expr</li>
<li>_ast.comprehension</li>
<li>_ast.AST</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.typedcomprehension.ifs"><code class="name">var <span class="ident">ifs</span> : List[<a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedcomprehension.iter"><code class="name">var <span class="ident">iter</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.typed_ast.typedcomprehension.target"><code class="name">var <span class="ident">target</span> : <a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.typedexpr"><code class="flex name class">
<span>class <span class="ident">typedexpr</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class typedexpr(TypedAST, expr):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.expr</li>
<li>_ast.AST</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.RawPlutoExpr" href="#hebi.typed_ast.RawPlutoExpr">RawPlutoExpr</a></li>
<li><a title="hebi.typed_ast.TypedAttribute" href="#hebi.typed_ast.TypedAttribute">TypedAttribute</a></li>
<li><a title="hebi.typed_ast.TypedBinOp" href="#hebi.typed_ast.TypedBinOp">TypedBinOp</a></li>
<li><a title="hebi.typed_ast.TypedBoolOp" href="#hebi.typed_ast.TypedBoolOp">TypedBoolOp</a></li>
<li><a title="hebi.typed_ast.TypedCall" href="#hebi.typed_ast.TypedCall">TypedCall</a></li>
<li><a title="hebi.typed_ast.TypedCompare" href="#hebi.typed_ast.TypedCompare">TypedCompare</a></li>
<li><a title="hebi.typed_ast.TypedDict" href="#hebi.typed_ast.TypedDict">TypedDict</a></li>
<li><a title="hebi.typed_ast.TypedExpression" href="#hebi.typed_ast.TypedExpression">TypedExpression</a></li>
<li><a title="hebi.typed_ast.TypedList" href="#hebi.typed_ast.TypedList">TypedList</a></li>
<li><a title="hebi.typed_ast.TypedListComp" href="#hebi.typed_ast.TypedListComp">TypedListComp</a></li>
<li><a title="hebi.typed_ast.TypedName" href="#hebi.typed_ast.TypedName">TypedName</a></li>
<li><a title="hebi.typed_ast.TypedSubscript" href="#hebi.typed_ast.TypedSubscript">TypedSubscript</a></li>
<li><a title="hebi.typed_ast.TypedTuple" href="#hebi.typed_ast.TypedTuple">TypedTuple</a></li>
<li><a title="hebi.typed_ast.TypedUnaryOp" href="#hebi.typed_ast.TypedUnaryOp">TypedUnaryOp</a></li>
<li><a title="hebi.typed_ast.typedcomprehension" href="#hebi.typed_ast.typedcomprehension">typedcomprehension</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.typedexpr.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="hebi.typed_ast.typedstmt"><code class="flex name class">
<span>class <span class="ident">typedstmt</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class typedstmt(TypedAST, stmt):
    # Statements always have type None
    typ = NoneInstanceType</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></li>
<li>_ast.stmt</li>
<li>_ast.AST</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hebi.typed_ast.TypedAnnAssign" href="#hebi.typed_ast.TypedAnnAssign">TypedAnnAssign</a></li>
<li><a title="hebi.typed_ast.TypedAssert" href="#hebi.typed_ast.TypedAssert">TypedAssert</a></li>
<li><a title="hebi.typed_ast.TypedAssign" href="#hebi.typed_ast.TypedAssign">TypedAssign</a></li>
<li><a title="hebi.typed_ast.TypedClassDef" href="#hebi.typed_ast.TypedClassDef">TypedClassDef</a></li>
<li><a title="hebi.typed_ast.TypedExpr" href="#hebi.typed_ast.TypedExpr">TypedExpr</a></li>
<li><a title="hebi.typed_ast.TypedFor" href="#hebi.typed_ast.TypedFor">TypedFor</a></li>
<li><a title="hebi.typed_ast.TypedFunctionDef" href="#hebi.typed_ast.TypedFunctionDef">TypedFunctionDef</a></li>
<li><a title="hebi.typed_ast.TypedIf" href="#hebi.typed_ast.TypedIf">TypedIf</a></li>
<li><a title="hebi.typed_ast.TypedIfExp" href="#hebi.typed_ast.TypedIfExp">TypedIfExp</a></li>
<li><a title="hebi.typed_ast.TypedModule" href="#hebi.typed_ast.TypedModule">TypedModule</a></li>
<li><a title="hebi.typed_ast.TypedPass" href="#hebi.typed_ast.TypedPass">TypedPass</a></li>
<li><a title="hebi.typed_ast.TypedReturn" href="#hebi.typed_ast.TypedReturn">TypedReturn</a></li>
<li><a title="hebi.typed_ast.TypedWhile" href="#hebi.typed_ast.TypedWhile">TypedWhile</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.typed_ast.typedstmt.typ"><code class="name">var <span class="ident">typ</span> : <a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="hebi Home" href="https://hebi.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/hebi/master/hebi.png" alt="hebi logo"> &nbsp; hebi
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hebi" href="index.html">hebi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hebi.typed_ast.FrozenFrozenList" href="#hebi.typed_ast.FrozenFrozenList">FrozenFrozenList</a></code></li>
<li><code><a title="hebi.typed_ast.distinct" href="#hebi.typed_ast.distinct">distinct</a></code></li>
<li><code><a title="hebi.typed_ast.empty_list" href="#hebi.typed_ast.empty_list">empty_list</a></code></li>
<li><code><a title="hebi.typed_ast.transform_ext_params_map" href="#hebi.typed_ast.transform_ext_params_map">transform_ext_params_map</a></code></li>
<li><code><a title="hebi.typed_ast.transform_output_map" href="#hebi.typed_ast.transform_output_map">transform_output_map</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hebi.typed_ast.AnyType" href="#hebi.typed_ast.AnyType">AnyType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.AnyType.attribute" href="#hebi.typed_ast.AnyType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.AnyType.attribute_type" href="#hebi.typed_ast.AnyType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.AnyType.cmp" href="#hebi.typed_ast.AnyType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.AnyType.constr" href="#hebi.typed_ast.AnyType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.AnyType.constr_type" href="#hebi.typed_ast.AnyType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.AtomicType" href="#hebi.typed_ast.AtomicType">AtomicType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.AtomicType.attribute" href="#hebi.typed_ast.AtomicType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.AtomicType.attribute_type" href="#hebi.typed_ast.AtomicType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.AtomicType.cmp" href="#hebi.typed_ast.AtomicType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.AtomicType.constr" href="#hebi.typed_ast.AtomicType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.AtomicType.constr_type" href="#hebi.typed_ast.AtomicType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.BoolType" href="#hebi.typed_ast.BoolType">BoolType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.BoolType.attribute" href="#hebi.typed_ast.BoolType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.BoolType.attribute_type" href="#hebi.typed_ast.BoolType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.BoolType.cmp" href="#hebi.typed_ast.BoolType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.BoolType.constr" href="#hebi.typed_ast.BoolType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.BoolType.constr_type" href="#hebi.typed_ast.BoolType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.ByteStringType" href="#hebi.typed_ast.ByteStringType">ByteStringType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.ByteStringType.attribute" href="#hebi.typed_ast.ByteStringType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.ByteStringType.attribute_type" href="#hebi.typed_ast.ByteStringType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.ByteStringType.cmp" href="#hebi.typed_ast.ByteStringType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.ByteStringType.constr" href="#hebi.typed_ast.ByteStringType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.ByteStringType.constr_type" href="#hebi.typed_ast.ByteStringType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.ClassType" href="#hebi.typed_ast.ClassType">ClassType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.ClassType.attribute" href="#hebi.typed_ast.ClassType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.ClassType.attribute_type" href="#hebi.typed_ast.ClassType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.ClassType.cmp" href="#hebi.typed_ast.ClassType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.ClassType.constr" href="#hebi.typed_ast.ClassType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.ClassType.constr_type" href="#hebi.typed_ast.ClassType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.DictType" href="#hebi.typed_ast.DictType">DictType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.DictType.attribute" href="#hebi.typed_ast.DictType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.attribute_type" href="#hebi.typed_ast.DictType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.cmp" href="#hebi.typed_ast.DictType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.constr" href="#hebi.typed_ast.DictType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.constr_type" href="#hebi.typed_ast.DictType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.key_typ" href="#hebi.typed_ast.DictType.key_typ">key_typ</a></code></li>
<li><code><a title="hebi.typed_ast.DictType.value_typ" href="#hebi.typed_ast.DictType.value_typ">value_typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.FunctionType" href="#hebi.typed_ast.FunctionType">FunctionType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.FunctionType.argtyps" href="#hebi.typed_ast.FunctionType.argtyps">argtyps</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.attribute" href="#hebi.typed_ast.FunctionType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.attribute_type" href="#hebi.typed_ast.FunctionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.cmp" href="#hebi.typed_ast.FunctionType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.constr" href="#hebi.typed_ast.FunctionType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.constr_type" href="#hebi.typed_ast.FunctionType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.FunctionType.rettyp" href="#hebi.typed_ast.FunctionType.rettyp">rettyp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.InaccessibleType" href="#hebi.typed_ast.InaccessibleType">InaccessibleType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.InaccessibleType.attribute" href="#hebi.typed_ast.InaccessibleType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.InaccessibleType.attribute_type" href="#hebi.typed_ast.InaccessibleType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.InaccessibleType.cmp" href="#hebi.typed_ast.InaccessibleType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.InaccessibleType.constr" href="#hebi.typed_ast.InaccessibleType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.InaccessibleType.constr_type" href="#hebi.typed_ast.InaccessibleType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.InstanceType" href="#hebi.typed_ast.InstanceType">InstanceType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.InstanceType.attribute" href="#hebi.typed_ast.InstanceType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.InstanceType.attribute_type" href="#hebi.typed_ast.InstanceType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.InstanceType.cmp" href="#hebi.typed_ast.InstanceType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.InstanceType.constr" href="#hebi.typed_ast.InstanceType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.InstanceType.constr_type" href="#hebi.typed_ast.InstanceType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.InstanceType.typ" href="#hebi.typed_ast.InstanceType.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.IntegerType" href="#hebi.typed_ast.IntegerType">IntegerType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.IntegerType.attribute" href="#hebi.typed_ast.IntegerType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.IntegerType.attribute_type" href="#hebi.typed_ast.IntegerType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.IntegerType.cmp" href="#hebi.typed_ast.IntegerType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.IntegerType.constr" href="#hebi.typed_ast.IntegerType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.IntegerType.constr_type" href="#hebi.typed_ast.IntegerType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.ListType" href="#hebi.typed_ast.ListType">ListType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.ListType.attribute" href="#hebi.typed_ast.ListType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.ListType.attribute_type" href="#hebi.typed_ast.ListType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.ListType.cmp" href="#hebi.typed_ast.ListType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.ListType.constr" href="#hebi.typed_ast.ListType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.ListType.constr_type" href="#hebi.typed_ast.ListType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.ListType.typ" href="#hebi.typed_ast.ListType.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.PairType" href="#hebi.typed_ast.PairType">PairType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.PairType.attribute" href="#hebi.typed_ast.PairType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.attribute_type" href="#hebi.typed_ast.PairType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.cmp" href="#hebi.typed_ast.PairType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.constr" href="#hebi.typed_ast.PairType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.constr_type" href="#hebi.typed_ast.PairType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.l_typ" href="#hebi.typed_ast.PairType.l_typ">l_typ</a></code></li>
<li><code><a title="hebi.typed_ast.PairType.r_typ" href="#hebi.typed_ast.PairType.r_typ">r_typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.PolymorphicFunction" href="#hebi.typed_ast.PolymorphicFunction">PolymorphicFunction</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.PolymorphicFunction.impl_from_args" href="#hebi.typed_ast.PolymorphicFunction.impl_from_args">impl_from_args</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunction.type_from_args" href="#hebi.typed_ast.PolymorphicFunction.type_from_args">type_from_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType" href="#hebi.typed_ast.PolymorphicFunctionInstanceType">PolymorphicFunctionInstanceType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.attribute" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.attribute_type" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.cmp" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.constr" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.constr_type" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.polymorphic_function" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.polymorphic_function">polymorphic_function</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionInstanceType.typ" href="#hebi.typed_ast.PolymorphicFunctionInstanceType.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.PolymorphicFunctionType" href="#hebi.typed_ast.PolymorphicFunctionType">PolymorphicFunctionType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.attribute" href="#hebi.typed_ast.PolymorphicFunctionType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.attribute_type" href="#hebi.typed_ast.PolymorphicFunctionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.cmp" href="#hebi.typed_ast.PolymorphicFunctionType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.constr" href="#hebi.typed_ast.PolymorphicFunctionType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.constr_type" href="#hebi.typed_ast.PolymorphicFunctionType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.PolymorphicFunctionType.polymorphic_function" href="#hebi.typed_ast.PolymorphicFunctionType.polymorphic_function">polymorphic_function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.RawPlutoExpr" href="#hebi.typed_ast.RawPlutoExpr">RawPlutoExpr</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.RawPlutoExpr.expr" href="#hebi.typed_ast.RawPlutoExpr.expr">expr</a></code></li>
<li><code><a title="hebi.typed_ast.RawPlutoExpr.typ" href="#hebi.typed_ast.RawPlutoExpr.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.Record" href="#hebi.typed_ast.Record">Record</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.Record.constructor" href="#hebi.typed_ast.Record.constructor">constructor</a></code></li>
<li><code><a title="hebi.typed_ast.Record.fields" href="#hebi.typed_ast.Record.fields">fields</a></code></li>
<li><code><a title="hebi.typed_ast.Record.name" href="#hebi.typed_ast.Record.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.RecordType" href="#hebi.typed_ast.RecordType">RecordType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.RecordType.attribute" href="#hebi.typed_ast.RecordType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.RecordType.attribute_type" href="#hebi.typed_ast.RecordType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.RecordType.cmp" href="#hebi.typed_ast.RecordType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.RecordType.constr" href="#hebi.typed_ast.RecordType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.RecordType.constr_type" href="#hebi.typed_ast.RecordType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.RecordType.record" href="#hebi.typed_ast.RecordType.record">record</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.StringType" href="#hebi.typed_ast.StringType">StringType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.StringType.attribute" href="#hebi.typed_ast.StringType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.StringType.attribute_type" href="#hebi.typed_ast.StringType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.StringType.cmp" href="#hebi.typed_ast.StringType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.StringType.constr" href="#hebi.typed_ast.StringType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.StringType.constr_type" href="#hebi.typed_ast.StringType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TupleType" href="#hebi.typed_ast.TupleType">TupleType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.TupleType.attribute" href="#hebi.typed_ast.TupleType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.TupleType.attribute_type" href="#hebi.typed_ast.TupleType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.TupleType.cmp" href="#hebi.typed_ast.TupleType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.TupleType.constr" href="#hebi.typed_ast.TupleType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.TupleType.constr_type" href="#hebi.typed_ast.TupleType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.TupleType.typs" href="#hebi.typed_ast.TupleType.typs">typs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.Type" href="#hebi.typed_ast.Type">Type</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.Type.attribute" href="#hebi.typed_ast.Type.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.Type.attribute_type" href="#hebi.typed_ast.Type.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.Type.cmp" href="#hebi.typed_ast.Type.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.Type.constr" href="#hebi.typed_ast.Type.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.Type.constr_type" href="#hebi.typed_ast.Type.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypeInferenceError" href="#hebi.typed_ast.TypeInferenceError">TypeInferenceError</a></code></h4>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedAST" href="#hebi.typed_ast.TypedAST">TypedAST</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedAST.typ" href="#hebi.typed_ast.TypedAST.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedAnnAssign" href="#hebi.typed_ast.TypedAnnAssign">TypedAnnAssign</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedAnnAssign.annotation" href="#hebi.typed_ast.TypedAnnAssign.annotation">annotation</a></code></li>
<li><code><a title="hebi.typed_ast.TypedAnnAssign.target" href="#hebi.typed_ast.TypedAnnAssign.target">target</a></code></li>
<li><code><a title="hebi.typed_ast.TypedAnnAssign.value" href="#hebi.typed_ast.TypedAnnAssign.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedAssert" href="#hebi.typed_ast.TypedAssert">TypedAssert</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedAssert.msg" href="#hebi.typed_ast.TypedAssert.msg">msg</a></code></li>
<li><code><a title="hebi.typed_ast.TypedAssert.test" href="#hebi.typed_ast.TypedAssert.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedAssign" href="#hebi.typed_ast.TypedAssign">TypedAssign</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedAssign.targets" href="#hebi.typed_ast.TypedAssign.targets">targets</a></code></li>
<li><code><a title="hebi.typed_ast.TypedAssign.value" href="#hebi.typed_ast.TypedAssign.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedAttribute" href="#hebi.typed_ast.TypedAttribute">TypedAttribute</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedAttribute.pos" href="#hebi.typed_ast.TypedAttribute.pos">pos</a></code></li>
<li><code><a title="hebi.typed_ast.TypedAttribute.value" href="#hebi.typed_ast.TypedAttribute.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedBinOp" href="#hebi.typed_ast.TypedBinOp">TypedBinOp</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedBinOp.left" href="#hebi.typed_ast.TypedBinOp.left">left</a></code></li>
<li><code><a title="hebi.typed_ast.TypedBinOp.right" href="#hebi.typed_ast.TypedBinOp.right">right</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedBoolOp" href="#hebi.typed_ast.TypedBoolOp">TypedBoolOp</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedBoolOp.values" href="#hebi.typed_ast.TypedBoolOp.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedCall" href="#hebi.typed_ast.TypedCall">TypedCall</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedCall.args" href="#hebi.typed_ast.TypedCall.args">args</a></code></li>
<li><code><a title="hebi.typed_ast.TypedCall.func" href="#hebi.typed_ast.TypedCall.func">func</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedClassDef" href="#hebi.typed_ast.TypedClassDef">TypedClassDef</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedClassDef.class_typ" href="#hebi.typed_ast.TypedClassDef.class_typ">class_typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedCompare" href="#hebi.typed_ast.TypedCompare">TypedCompare</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedCompare.comparators" href="#hebi.typed_ast.TypedCompare.comparators">comparators</a></code></li>
<li><code><a title="hebi.typed_ast.TypedCompare.left" href="#hebi.typed_ast.TypedCompare.left">left</a></code></li>
<li><code><a title="hebi.typed_ast.TypedCompare.ops" href="#hebi.typed_ast.TypedCompare.ops">ops</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedConstant" href="#hebi.typed_ast.TypedConstant">TypedConstant</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedConstant.typ" href="#hebi.typed_ast.TypedConstant.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedDict" href="#hebi.typed_ast.TypedDict">TypedDict</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedDict.typ" href="#hebi.typed_ast.TypedDict.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedExpr" href="#hebi.typed_ast.TypedExpr">TypedExpr</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedExpr.value" href="#hebi.typed_ast.TypedExpr.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedExpression" href="#hebi.typed_ast.TypedExpression">TypedExpression</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedExpression.body" href="#hebi.typed_ast.TypedExpression.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedFor" href="#hebi.typed_ast.TypedFor">TypedFor</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedFor.body" href="#hebi.typed_ast.TypedFor.body">body</a></code></li>
<li><code><a title="hebi.typed_ast.TypedFor.iter" href="#hebi.typed_ast.TypedFor.iter">iter</a></code></li>
<li><code><a title="hebi.typed_ast.TypedFor.orelse" href="#hebi.typed_ast.TypedFor.orelse">orelse</a></code></li>
<li><code><a title="hebi.typed_ast.TypedFor.target" href="#hebi.typed_ast.TypedFor.target">target</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedFunctionDef" href="#hebi.typed_ast.TypedFunctionDef">TypedFunctionDef</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedFunctionDef.args" href="#hebi.typed_ast.TypedFunctionDef.args">args</a></code></li>
<li><code><a title="hebi.typed_ast.TypedFunctionDef.body" href="#hebi.typed_ast.TypedFunctionDef.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedIf" href="#hebi.typed_ast.TypedIf">TypedIf</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedIf.body" href="#hebi.typed_ast.TypedIf.body">body</a></code></li>
<li><code><a title="hebi.typed_ast.TypedIf.orelse" href="#hebi.typed_ast.TypedIf.orelse">orelse</a></code></li>
<li><code><a title="hebi.typed_ast.TypedIf.test" href="#hebi.typed_ast.TypedIf.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedIfExp" href="#hebi.typed_ast.TypedIfExp">TypedIfExp</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedIfExp.body" href="#hebi.typed_ast.TypedIfExp.body">body</a></code></li>
<li><code><a title="hebi.typed_ast.TypedIfExp.orelse" href="#hebi.typed_ast.TypedIfExp.orelse">orelse</a></code></li>
<li><code><a title="hebi.typed_ast.TypedIfExp.test" href="#hebi.typed_ast.TypedIfExp.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedList" href="#hebi.typed_ast.TypedList">TypedList</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedList.typ" href="#hebi.typed_ast.TypedList.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedListComp" href="#hebi.typed_ast.TypedListComp">TypedListComp</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedListComp.elt" href="#hebi.typed_ast.TypedListComp.elt">elt</a></code></li>
<li><code><a title="hebi.typed_ast.TypedListComp.generators" href="#hebi.typed_ast.TypedListComp.generators">generators</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedModule" href="#hebi.typed_ast.TypedModule">TypedModule</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedModule.body" href="#hebi.typed_ast.TypedModule.body">body</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedName" href="#hebi.typed_ast.TypedName">TypedName</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedName.typ" href="#hebi.typed_ast.TypedName.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedNodeTransformer" href="#hebi.typed_ast.TypedNodeTransformer">TypedNodeTransformer</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedNodeTransformer.visit" href="#hebi.typed_ast.TypedNodeTransformer.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedNodeVisitor" href="#hebi.typed_ast.TypedNodeVisitor">TypedNodeVisitor</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedNodeVisitor.visit" href="#hebi.typed_ast.TypedNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedPass" href="#hebi.typed_ast.TypedPass">TypedPass</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedPass.typ" href="#hebi.typed_ast.TypedPass.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedReturn" href="#hebi.typed_ast.TypedReturn">TypedReturn</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedReturn.value" href="#hebi.typed_ast.TypedReturn.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedSubscript" href="#hebi.typed_ast.TypedSubscript">TypedSubscript</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedSubscript.value" href="#hebi.typed_ast.TypedSubscript.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedTuple" href="#hebi.typed_ast.TypedTuple">TypedTuple</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedTuple.typ" href="#hebi.typed_ast.TypedTuple.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedUnaryOp" href="#hebi.typed_ast.TypedUnaryOp">TypedUnaryOp</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedUnaryOp.operand" href="#hebi.typed_ast.TypedUnaryOp.operand">operand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.TypedWhile" href="#hebi.typed_ast.TypedWhile">TypedWhile</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.TypedWhile.body" href="#hebi.typed_ast.TypedWhile.body">body</a></code></li>
<li><code><a title="hebi.typed_ast.TypedWhile.orelse" href="#hebi.typed_ast.TypedWhile.orelse">orelse</a></code></li>
<li><code><a title="hebi.typed_ast.TypedWhile.test" href="#hebi.typed_ast.TypedWhile.test">test</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.UnionType" href="#hebi.typed_ast.UnionType">UnionType</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.UnionType.attribute" href="#hebi.typed_ast.UnionType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.UnionType.attribute_type" href="#hebi.typed_ast.UnionType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.UnionType.cmp" href="#hebi.typed_ast.UnionType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.UnionType.constr" href="#hebi.typed_ast.UnionType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.UnionType.constr_type" href="#hebi.typed_ast.UnionType.constr_type">constr_type</a></code></li>
<li><code><a title="hebi.typed_ast.UnionType.typs" href="#hebi.typed_ast.UnionType.typs">typs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.UnitType" href="#hebi.typed_ast.UnitType">UnitType</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.UnitType.attribute" href="#hebi.typed_ast.UnitType.attribute">attribute</a></code></li>
<li><code><a title="hebi.typed_ast.UnitType.attribute_type" href="#hebi.typed_ast.UnitType.attribute_type">attribute_type</a></code></li>
<li><code><a title="hebi.typed_ast.UnitType.cmp" href="#hebi.typed_ast.UnitType.cmp">cmp</a></code></li>
<li><code><a title="hebi.typed_ast.UnitType.constr" href="#hebi.typed_ast.UnitType.constr">constr</a></code></li>
<li><code><a title="hebi.typed_ast.UnitType.constr_type" href="#hebi.typed_ast.UnitType.constr_type">constr_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.typedarg" href="#hebi.typed_ast.typedarg">typedarg</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.typedarg.typ" href="#hebi.typed_ast.typedarg.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.typedarguments" href="#hebi.typed_ast.typedarguments">typedarguments</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.typed_ast.typedarguments.args" href="#hebi.typed_ast.typedarguments.args">args</a></code></li>
<li><code><a title="hebi.typed_ast.typedarguments.defaults" href="#hebi.typed_ast.typedarguments.defaults">defaults</a></code></li>
<li><code><a title="hebi.typed_ast.typedarguments.kw_defaults" href="#hebi.typed_ast.typedarguments.kw_defaults">kw_defaults</a></code></li>
<li><code><a title="hebi.typed_ast.typedarguments.kwarg" href="#hebi.typed_ast.typedarguments.kwarg">kwarg</a></code></li>
<li><code><a title="hebi.typed_ast.typedarguments.kwonlyargs" href="#hebi.typed_ast.typedarguments.kwonlyargs">kwonlyargs</a></code></li>
<li><code><a title="hebi.typed_ast.typedarguments.vararg" href="#hebi.typed_ast.typedarguments.vararg">vararg</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.typedcomprehension" href="#hebi.typed_ast.typedcomprehension">typedcomprehension</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.typedcomprehension.ifs" href="#hebi.typed_ast.typedcomprehension.ifs">ifs</a></code></li>
<li><code><a title="hebi.typed_ast.typedcomprehension.iter" href="#hebi.typed_ast.typedcomprehension.iter">iter</a></code></li>
<li><code><a title="hebi.typed_ast.typedcomprehension.target" href="#hebi.typed_ast.typedcomprehension.target">target</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.typedexpr" href="#hebi.typed_ast.typedexpr">typedexpr</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.typedexpr.typ" href="#hebi.typed_ast.typedexpr.typ">typ</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.typed_ast.typedstmt" href="#hebi.typed_ast.typedstmt">typedstmt</a></code></h4>
<ul class="">
<li><code><a title="hebi.typed_ast.typedstmt.typ" href="#hebi.typed_ast.typedstmt.typ">typ</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>