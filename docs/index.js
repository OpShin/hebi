URLS=[
"hebi/index.html",
"hebi/typed_ast.html",
"hebi/tests/index.html",
"hebi/tests/test_builtins.html",
"hebi/tests/test_misc.html",
"hebi/tests/test_ops.html",
"hebi/tests/test_ledger/index.html",
"hebi/tests/test_ledger/test_interval.html",
"hebi/tests/test_ledger/test_api_v2.html",
"hebi/tests/test_std/index.html",
"hebi/tests/test_std/test_math.html",
"hebi/tests/test_std/test_fractions.html",
"hebi/tests/test_stdlib.html",
"hebi/builder.html",
"hebi/ledger/index.html",
"hebi/ledger/api_v2.html",
"hebi/ledger/interval.html",
"hebi/optimize/index.html",
"hebi/optimize/optimize_varlen.html",
"hebi/util.html",
"hebi/optimize/optimize_remove_pass.html",
"hebi/optimize/optimize_remove_comments.html",
"hebi/optimize/optimize_remove_deadvars.html",
"hebi/compiler.html",
"hebi/rewrite/index.html",
"hebi/rewrite/rewrite_remove_type_stuff.html",
"hebi/rewrite/rewrite_duplicate_assignment.html",
"hebi/rewrite/rewrite_import_typing.html",
"hebi/rewrite/rewrite_inject_builtin_constr.html",
"hebi/rewrite/rewrite_import_dataclasses.html",
"hebi/rewrite/rewrite_subscript38.html",
"hebi/rewrite/rewrite_forbidden_overwrites.html",
"hebi/rewrite/rewrite_inject_builtins.html",
"hebi/rewrite/rewrite_import_plutusdata.html",
"hebi/rewrite/rewrite_zero_ary.html",
"hebi/rewrite/rewrite_import_hashlib.html",
"hebi/rewrite/rewrite_tuple_assign.html",
"hebi/rewrite/rewrite_import.html",
"hebi/std/index.html",
"hebi/std/math.html",
"hebi/std/fractions.html",
"hebi/type_inference.html",
"hebi/prelude.html"
];
INDEX=[
{
"ref":"hebi",
"url":0,
"doc":"    hebi                > You are building what you want. Why not also build  how you want? This is an implementation of smart contracts for Cardano which are written in a very strict subset of valid Python. The general philosophy of this project is to write a compiler that ensure the following: If the program compiles then: 1. it is a valid Python program 2. the output running it with python is the same as running it on-chain. > Note this is the sister project of [eopsin](https: github.com/ImperatorLang/eopsin). It uses an even more restricted subset of python (for example no while loops). The benefit is that the resulting code is greatly reduced in size and cpu/memory consumption.  Why hebi? - 100% valid Python. Leverage the existing tool stack for Python, syntax highlighting, linting, debugging, unit-testing, [property-based testing](https: hypothesis.readthedocs.io/), [verification](https: github.com/marcoeilers/nagini) - Intuitive. Just like Python. - Functional. Forces you to write elegant, functional code in Python. - Efficient & Secure. Static type inference ensures strict typing and optimized code Eopsin is more comfortable to use than hebi. If you want to start building, write your contract in eopsin first. Then, after everything works to your pleasing, try to port to hebi and enjoy the performance gains.  Getting Started  OpShin Pioneer Program Check out the [opshin-pioneer-program]( https: github.com/OpShin/opshin-pioneer-program) for a host of educational example contracts, test cases and off-chain code.  Example repository Check out the [opshin-starter-kit]( https: github.com/OpShin/opshin-starter-kit) repository for a quick start in setting up a development environment and compiling some sample contracts yourself. You can replace the contracts in your local copy of the repository with code from the  examples section here to start exploring different contracts.  Developer Community and Questions The eopsin repository contains a discussions page. Feel free to open up a new discussion with questions regarding development using hebi and using certain features. Others may be able to help you and will also benefit from the previously shared questions. Check out the community [here](https: github.com/OpShin/opshin/discussions) You can also chat with other developers [in the welcoming discord community](https: discord.gg/umR3A2g4uw) of OpShin  Installation Install Python 3.8, 3.9 or 3.10. Then run   python3 -m pip install hebi    Writing a Smart Contract A short non-complete introduction in starting to write smart contracts follows. 1. Make sure you understand EUTxOs, Addresses, Validators etc on Cardano. [There is a wonderful crashcourse by @KtorZ](https: aiken-lang.org/fundamentals/eutxo). The contract will work on these concepts 2. Make sure you understand python. hebi works like python and uses python. There are tons of tutorials for python, choose what suits you best. 3. Make sure your contract is valid python and the types check out. Write simple contracts first and run them using  hebi eval to get a feeling for how they work. 4. Make sure your contract is valid hebi code. Run  hebi compile and look at the compiler erros for guidance along what works and doesn't work and why. 5. Dig into the [ examples ](https: github.com/OpShin/hebi/tree/main/examples) to understand common patterns. Check out the [ prelude ](https: hebi.opshin.dev/hebi/prelude.html) for understanding how the Script Context is structured and how complex datums are defined. 6. Check out the [sample repository](https: github.com/OpShin/opshin-starter-kit) to find a sample setup for developing your own contract. In summary, a smart contract in hebi is defined by the function  validator in your contract file. The function validates that a specific value can be spent, minted, burned, withdrawn etc, depending on where it is invoked/used as a credential. If the function fails (i.e. raises an error of any kind such as a  KeyError or  AssertionError ) the validation is denied, and the funds can not be spent, minted, burned etc. > There is a subtle difference here in comparison to most other Smart Contract languages. > In hebi a validator may return anything (in particular also  False ) - as long as it does not fail, the execution is considered valid. > This is more similar to how contracts in Solidity always pass, unless they run out of gas or hit an error. > So make sure to  assert what you want to ensure to hold for validation! A simple contract called the \"Gift Contract\" verifies that only specific wallets can withdraw money. They are authenticated by a signature. If you don't understand what a pubkeyhash is and how this validates anything, check out [this gentle introduction into Cardanos EUTxO](https: aiken-lang.org/fundamentals/eutxo). Also see the [tutorial by  pycardano ](https: pycardano.readthedocs.io/en/latest/guides/plutus.html) for explanations on what each of the parameters to the validator means and how to build transactions with the contract.   from hebi.prelude import  @dataclass class WithdrawDatum(PlutusData): pubkeyhash: bytes def validator(datum: WithdrawDatum, redeemer: None, context: ScriptContext) -> None: assert datum.pubkeyhash in context.tx_info.signatories, \"Required signature missing\"   All contracts written in hebi are 100% valid python. Minting policies expect only a redeemer and script context as argument. Check out the [Architecture guide](https: github.com/OpShin/hebi/blob/main/ARCHITECTURE.md minting-policy -spending-validator-double-function) for details on how to write double functioning contracts. The [ examples ](https: github.com/OpShin/hebi/blob/main/examples) folder contains more examples. Also check out the [opshin-pioneer-program]( https: github.com/OpShin/opshin-pioneer-program) and [opshin-starter-kit]( https: github.com/OpShin/opshin-starter-kit) repo.  Compiling Write your program in python. You may start with the content of  examples . Arguments to scripts are passed in as Plutus Data objects in JSON notation. You can run any of the following commands    Evaluate script in Python - this can be used to make sure there are no obvious errors hebi eval examples/smart_contracts/assert_sum.py \"{\\\"int\\\": 4}\" \"{\\\"int\\\": 38}\" \"{\\\"constructor\\\": 0, \\\"fields\\\": []}\"  Compile script to 'uplc', the Cardano Smart Contract assembly hebi compile examples/smart_contracts/assert_sum.py    Deploying The deploy process generates all artifacts required for usage with common libraries like [pycardano](https: github.com/Python-Cardano/pycardano), [lucid](https: github.com/spacebudz/lucid) and the [cardano-cli](https: github.com/input-output-hk/cardano-node).    Automatically generate all artifacts needed for using this contract hebi build examples/smart_contracts/assert_sum.py   See the [tutorial by  pycardano ](https: pycardano.readthedocs.io/en/latest/guides/plutus.html) for explanations how to build transactions with  opshin contracts.  The small print _Not every valid python program is a valid smart contract_. Not all language features of python will or can be supported. The reasons are mainly of practical nature (i.e. we can't infer types when functions like  eval are allowed). Specifically, only a pure subset of python is allowed. Further, only immutable objects may be generated. For your program to be accepted, make sure to only make use of language constructs supported by the compiler. You will be notified of which constructs are not supported when trying to compile.  Name Hebi is japanese for \"snake\", which is a play on words on  python , the underlying language.  Versioning scheme Since this project builds on top of eopsin, it has a particular versioning scheme. The first three numbers indicate the version of  hebi (starting at  0.1.0 ). Then follows the latest version number of  eopsin which was merged into the project (starting at  0.9.3 ). This is intended to help navigating releases among both packages, where it might be important that a recent eopsin release is integrated that contains a security patch.  Contributing  Architecture This program consists of a few independent components: 1. An aggressive static type inferencer 2. Rewriting tools to simplify complex python expressions 3. A compiler from a subset of python into UPLC  Debugging artefacts For debugging purposes, you can also run    Compile script to 'uplc', and evaluate the script in UPLC (for debugging purposes) python3 -m hebi eval_uplc examples/smart_contracts/assert_sum.py \"{\\\"int\\\": 4}\" \"{\\\"int\\\": 38}\" \"{\\\"constructor\\\": 0, \\\"fields\\\": []}\"  Compile script to 'pluto', an intermediate language (for debugging purposes) python3 -m hebi compile_pluto examples/smart_contracts/assert_sum.py    Sponsoring You can sponsor the development of hebi through GitHub or [Teiki](https: alpha.teiki.network/projects/opshin) or just by sending ADA. Drop me a message on social media and let me know what it is for. -  [Teiki](https: alpha.teiki.network/projects/opshin) Stake your ada to support OpShin at [Teiki](https: alpha.teiki.network/projects/opshin) -  GitHub Sponsor the developers of this project through the button \"Sponsor\" next to them -  ADA Donation in ADA can be submitted to  $opshin or  addr1qyz3vgd5xxevjy2rvqevz9n7n7dney8n6hqggp23479fm6vwpj9clsvsf85cd4xc59zjztr5zwpummwckmzr2myjwjns74lhmr .  Supporters          The main sponsor of this project is [Inversion](https: inversion.dev/cardano/). Here is a word from them! > At Inversion, we pride ourselves on our passion for life and our ability to create exceptional software solutions for our clients. Our team of experts, with over a century of cumulative experience, is dedicated to harnessing the power of the Cardano blockchain to bring innovative and scalable decentralized applications to life. We've successfully built applications for NFT management, staking and delegation, chain data monitoring, analytics, and web3 integrations, as well as countless non-blockchain systems. With a focus on security, transparency, and sustainability, our team is excited to contribute to the Cardano ecosystem, pushing the boundaries of decentralized technologies to improve lives worldwide. Trust Inversion to be your go-to partner for robust, effective, and forward-thinking solutions, whether blockchain based, traditional systems, or a mix of the two. They have recently started a podcast, called \"Africa On Chain\", which you can check out here: https: www.youtube.com/@africaonchain"
},
{
"ref":"hebi.typed_ast",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.FunctionType",
"url":1,
"doc":"FunctionType(argtyps: List[hebi.typed_ast.Type], rettyp: hebi.typed_ast.Type)"
},
{
"ref":"hebi.typed_ast.FunctionType.argtyps",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.FunctionType.rettyp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.FunctionType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.FunctionType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.FunctionType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.FunctionType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.FunctionType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.distinct",
"url":1,
"doc":"Returns true iff the list consists of distinct elements",
"func":1
},
{
"ref":"hebi.typed_ast.FrozenFrozenList",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.Type",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.Type.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.Type.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.Type.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.Type.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.Type.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.Record",
"url":1,
"doc":"Record(name: str, constructor: int, fields: Union[List[Tuple[str, hebi.typed_ast.Type , frozenlist._frozenlist.FrozenList])"
},
{
"ref":"hebi.typed_ast.Record.name",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.Record.constructor",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.Record.fields",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.ClassType",
"url":1,
"doc":"ClassType()"
},
{
"ref":"hebi.typed_ast.ClassType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ClassType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ClassType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.ClassType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.ClassType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.AnyType",
"url":1,
"doc":"The top element in the partial order on types"
},
{
"ref":"hebi.typed_ast.AnyType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.AnyType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.AnyType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.AnyType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.AnyType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.AtomicType",
"url":1,
"doc":"AtomicType()"
},
{
"ref":"hebi.typed_ast.AtomicType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.AtomicType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.AtomicType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.AtomicType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.AtomicType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.RecordType",
"url":1,
"doc":"RecordType(record: hebi.typed_ast.Record)"
},
{
"ref":"hebi.typed_ast.RecordType.record",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.RecordType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.RecordType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.RecordType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.RecordType.attribute",
"url":1,
"doc":"The attributes of this class. Need to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.RecordType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.UnionType",
"url":1,
"doc":"UnionType(typs: List[hebi.typed_ast.RecordType])"
},
{
"ref":"hebi.typed_ast.UnionType.typs",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.UnionType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.UnionType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.UnionType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.UnionType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.UnionType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.TupleType",
"url":1,
"doc":"TupleType(typs: List[hebi.typed_ast.Type])"
},
{
"ref":"hebi.typed_ast.TupleType.typs",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TupleType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.TupleType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.TupleType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.TupleType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.TupleType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.PairType",
"url":1,
"doc":"An internal type representing built-in PlutusData pairs"
},
{
"ref":"hebi.typed_ast.PairType.l_typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PairType.r_typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PairType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PairType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PairType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.PairType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.PairType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.ListType",
"url":1,
"doc":"ListType(typ: hebi.typed_ast.Type)"
},
{
"ref":"hebi.typed_ast.ListType.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.ListType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ListType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ListType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.ListType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.ListType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.DictType",
"url":1,
"doc":"DictType(key_typ: hebi.typed_ast.Type, value_typ: hebi.typed_ast.Type)"
},
{
"ref":"hebi.typed_ast.DictType.key_typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.DictType.value_typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.DictType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.DictType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.DictType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.DictType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.DictType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.InstanceType",
"url":1,
"doc":"InstanceType(typ: hebi.typed_ast.ClassType)"
},
{
"ref":"hebi.typed_ast.InstanceType.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.InstanceType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.InstanceType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.InstanceType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.InstanceType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.InstanceType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.IntegerType",
"url":1,
"doc":"IntegerType()"
},
{
"ref":"hebi.typed_ast.IntegerType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.IntegerType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.IntegerType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.IntegerType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.IntegerType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.StringType",
"url":1,
"doc":"StringType()"
},
{
"ref":"hebi.typed_ast.StringType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.StringType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.StringType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.StringType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.StringType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.ByteStringType",
"url":1,
"doc":"ByteStringType()"
},
{
"ref":"hebi.typed_ast.ByteStringType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ByteStringType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.ByteStringType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.ByteStringType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.ByteStringType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.BoolType",
"url":1,
"doc":"BoolType()"
},
{
"ref":"hebi.typed_ast.BoolType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.BoolType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.BoolType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.BoolType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.BoolType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.UnitType",
"url":1,
"doc":"UnitType()"
},
{
"ref":"hebi.typed_ast.UnitType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.UnitType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.UnitType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.UnitType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.UnitType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.InaccessibleType",
"url":1,
"doc":"A type that blocks overwriting of a function"
},
{
"ref":"hebi.typed_ast.InaccessibleType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.InaccessibleType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.InaccessibleType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.InaccessibleType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.InaccessibleType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunction",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PolymorphicFunction.type_from_args",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunction.impl_from_args",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType",
"url":1,
"doc":"A special type of builtin that may act differently on different parameters"
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.polymorphic_function",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType",
"url":1,
"doc":"PolymorphicFunctionInstanceType(typ: hebi.typed_ast.FunctionType, polymorphic_function: hebi.typed_ast.PolymorphicFunction)"
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.polymorphic_function",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.attribute_type",
"url":1,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.attribute",
"url":1,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.typed_ast.PolymorphicFunctionInstanceType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.typed_ast.TypedAST",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAST.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedexpr",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedexpr.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedstmt",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedstmt.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarg",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarg.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.args",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.vararg",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.kwonlyargs",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.kw_defaults",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.kwarg",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedarguments.defaults",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedModule",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedModule.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFunctionDef",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFunctionDef.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFunctionDef.args",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIf",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIf.test",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIf.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIf.orelse",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedReturn",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedReturn.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedExpression",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedExpression.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCall",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCall.func",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCall.args",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedExpr",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedExpr.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssign",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssign.targets",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssign.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedClassDef",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedClassDef.class_typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAnnAssign",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAnnAssign.target",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAnnAssign.annotation",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAnnAssign.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedWhile",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedWhile.test",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedWhile.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedWhile.orelse",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFor",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFor.target",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFor.iter",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFor.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedFor.orelse",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedPass",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedPass.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedName",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedName.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedConstant",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedConstant.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedTuple",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedTuple.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedList",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedList.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedcomprehension",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedcomprehension.target",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedcomprehension.iter",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.typedcomprehension.ifs",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedListComp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedListComp.generators",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedListComp.elt",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedDict",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedDict.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIfExp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIfExp.test",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIfExp.body",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedIfExp.orelse",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCompare",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCompare.left",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCompare.ops",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedCompare.comparators",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedBinOp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedBinOp.left",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedBinOp.right",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedBoolOp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedBoolOp.values",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedUnaryOp",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedUnaryOp.operand",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedSubscript",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedSubscript.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAttribute",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAttribute.value",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAttribute.pos",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssert",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssert.test",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypedAssert.msg",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.RawPlutoExpr",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.RawPlutoExpr.typ",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.RawPlutoExpr.expr",
"url":1,
"doc":""
},
{
"ref":"hebi.typed_ast.TypeInferenceError",
"url":1,
"doc":"Assertion failed."
},
{
"ref":"hebi.typed_ast.empty_list",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.transform_ext_params_map",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.transform_output_map",
"url":1,
"doc":"",
"func":1
},
{
"ref":"hebi.typed_ast.TypedNodeTransformer",
"url":1,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.typed_ast.TypedNodeTransformer.visit",
"url":1,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.typed_ast.TypedNodeVisitor",
"url":1,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.typed_ast.TypedNodeVisitor.visit",
"url":1,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.tests",
"url":2,
"doc":""
},
{
"ref":"hebi.tests.test_builtins",
"url":3,
"doc":""
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest",
"url":3,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_all",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_any",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_abs",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_bytes_int_list",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_chr",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_hex",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string",
"url":3,
"doc":""
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_0_10_00",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_1_00",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_2__",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_3__1",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_4__10238",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_5_19293812983721837981",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_int_string_6_jakjsdh",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_len_bytestring",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_len_lists",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_max",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_min",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_pow",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_oct",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_range",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_str_int",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_sum",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_reversed",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_builtins.BuiltinTest.test_bool_constr_int",
"url":3,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc",
"url":4,
"doc":""
},
{
"ref":"hebi.tests.test_misc.fib",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest",
"url":4,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_assert_sum_contract_succeed",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_assert_sum_contract_fail",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_sum",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_complex_datum_correct_vals",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_hello_world",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_list_datum_correct_vals",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_showcase",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_fib_rec",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_gift_contract_succeed",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_gift_contract_fail",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_recursion",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_datum_cast",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_wrapping_contract_compile",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_dual_use_compile",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_marketplace_compile",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_marketplace_compile_fail",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_parameterized_compile",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_dict_datum",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_overopt_removedeadvar",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_opt_shared_var",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_list_expr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_redefine_constr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_wrap_into_generic_data",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_list_comprehension_even",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_list_comprehension_all",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_union_type_attr_access_all_records",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_union_type_all_records_same_constr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_union_type_attr_access_all_records_same_constr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_union_type_attr_access_maximum_type",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_union_type_attr_anytype",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_no_reassign",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_anything_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_int_anything",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_int_anything_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_anything_int_anything",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_int_str",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_typecast_int_int",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_zero_ary",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_zero_ary_exec",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_zero_ary_method",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_zero_ary_method_exec",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_return_anything",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_no_return_annotation",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_no_parameter_annotation",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_dict_items_values_deconstr",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_misc.MiscTest.test_nested_deconstruction",
"url":4,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops",
"url":5,
"doc":""
},
{
"ref":"hebi.tests.test_ops.OpTest",
"url":5,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"hebi.tests.test_ops.OpTest.test_and_bool",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_or_bool",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_not_bool",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_usub_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_add_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_sub_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_mul_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_div_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_mod_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_pow_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_add_bytes",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_add_str",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_slice_bytes",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_index_bytes",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_index_list",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_in_list_int",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_in_list_bytes",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_eq_bytes",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_eq_str",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ops.OpTest.test_eq_bool",
"url":5,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger",
"url":6,
"doc":""
},
{
"ref":"hebi.tests.test_ledger.test_interval",
"url":7,
"doc":""
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_ordering_compare",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_commutative_compare_extended",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_ordering_compare_extended",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_ordering_compare_lower_bound",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_commutative_lower_bound",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_ordering_compare_upper_bound",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_commutative_compare_upper_bound",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_contains",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_fuzz_make_from",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_fuzz_make_range",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_fuzz_make_to",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_fuzz_compare_extended_helper",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_get_bool",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_make_to_in_make_range",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_interval.test_make_from_in_make_range",
"url":7,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_api_v2",
"url":8,
"doc":""
},
{
"ref":"hebi.tests.test_ledger.test_api_v2.test_script_context_repr_correct_0_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87980d87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820746957f0eb57f2b11119684e611a98f373afea93473fefbb7632d579af2f6259ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":8,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_api_v2.test_script_context_repr_correct_1_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff80a1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820797a1e1720b63621c6b185088184cb8e23af6e46b55bd83e7a91024c823a6c2affffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":8,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_ledger.test_api_v2.test_script_context_repr_correct_2_d8799fd8799f9fd8799fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffd8799fd8799fd87a9f581cdbe769758f26efb21f008dc097bb194cffc622acc37fcefc5372eee3ffd87a80ffa140a1401a00989680d87a9f5820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dffd87a80ffffff809fd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a14000d87980d87a80ffd8799fd8799fd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd87a80ffa140a1401a000f4240d87980d87a80ffffa140a14000a140a1400080a0d8799fd8799fd87a9f1b000001836ac117d8ffd87a80ffd8799fd87b80d87a80ffff9f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffa1d87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffd87980a15820dfab81872ce2bbe6ee5af9bbfee4047f91c1f57db5e30da727d5fef1e7f02f4dd8799f581cdc315c289fee4484eda07038393f21dc4e572aff292d7926018725c2ffd8799f5820c17c32f6433ae22c2acaebfb796bbfaee3993ff7ebb58a2bac6b4a3bdd2f6d28ffffd87a9fd8799fd8799f582055d353acacaab6460b37ed0f0e3a1a0aabf056df4a7fa1e265d21149ccacc527ff01ffffff",
"url":8,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std",
"url":9,
"doc":""
},
{
"ref":"hebi.tests.test_std.test_math",
"url":10,
"doc":""
},
{
"ref":"hebi.tests.test_std.test_math.test_gcd",
"url":10,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_math.test_sign",
"url":10,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_math.test_unsigned_int_from_bytes_big",
"url":10,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions",
"url":11,
"doc":""
},
{
"ref":"hebi.tests.test_std.test_fractions.native_fraction_from_oc_fraction",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_add",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_sub",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_neg",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_mul",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_div",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_norm_sign",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_norm",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_ge",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_le",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_lt",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_gt",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_std.test_fractions.test_eq",
"url":11,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib",
"url":12,
"doc":""
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest",
"url":12,
"doc":"A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes:  failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'.  longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in  addition to any explicit message passed.  maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name."
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_get",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_subscript",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_keys",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_values",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_items_keys_sum",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_dict_items_values_sum",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_str_encode",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_str_decode",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_constant_bytestring",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_constant_integer",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_constant_string",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_constant_unit",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.tests.test_stdlib.StdlibTest.test_constant_bool",
"url":12,
"doc":"",
"func":1
},
{
"ref":"hebi.builder",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.ScriptArtifacts",
"url":13,
"doc":"ScriptArtifacts(cbor_hex: str, plutus_json: str, mainnet_addr: str, testnet_addr: str, policy_id: str)"
},
{
"ref":"hebi.builder.ScriptArtifacts.cbor_hex",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.ScriptArtifacts.plutus_json",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.ScriptArtifacts.mainnet_addr",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.ScriptArtifacts.testnet_addr",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.ScriptArtifacts.policy_id",
"url":13,
"doc":""
},
{
"ref":"hebi.builder.build",
"url":13,
"doc":"Expects a python module and returns the build artifacts from compiling it",
"func":1
},
{
"ref":"hebi.builder.generate_artifacts",
"url":13,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger",
"url":14,
"doc":""
},
{
"ref":"hebi.ledger.api_v2",
"url":15,
"doc":"The PlutusV2 ledger API"
},
{
"ref":"hebi.ledger.api_v2.TxId",
"url":15,
"doc":"A transaction id, a 64 bytes long hash of the transaction body (also called transaction hash). Example value: TxId(bytes.fromhex(\"842a4d37b036da6ab3c04331240e67d81746beb44f23ad79703e026705361956\" "
},
{
"ref":"hebi.ledger.api_v2.TxId.tx_id",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Nothing",
"url":15,
"doc":"Nothing, can be used to signify non-importance of a parameter to a function Example value: Nothing()"
},
{
"ref":"hebi.ledger.api_v2.Nothing.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TrueData",
"url":15,
"doc":"A Datum that represents True in Haskell implementations. It is thus used as an encoding for True in the ScriptContext. Example value: TrueData()"
},
{
"ref":"hebi.ledger.api_v2.TrueData.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.FalseData",
"url":15,
"doc":"A Datum that represents False in Haskell implementations. It is thus used as an encoding for False in the ScriptContext. Example value: FalseData()"
},
{
"ref":"hebi.ledger.api_v2.FalseData.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOutRef",
"url":15,
"doc":"A reference to a transaction output (hash/id + index)"
},
{
"ref":"hebi.ledger.api_v2.TxOutRef.id",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOutRef.idx",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.PubKeyCredential",
"url":15,
"doc":"Part of an address that is authenticated by a public key hash Example value: PubKeyCredential(bytes.fromhex(\"c06ddaad12fc4ded18e56feac72957c1aa75fce6096b40e63ec88274\" "
},
{
"ref":"hebi.ledger.api_v2.PubKeyCredential.credential_hash",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.PubKeyCredential.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.ScriptCredential",
"url":15,
"doc":"Part of an address that is authenticated by a smart cotnract Example value: ScriptCredential(bytes.fromhex(\"c06ddaad12fc4ded18e56feac72957c1aa75fce6096b40e63ec88274\" "
},
{
"ref":"hebi.ledger.api_v2.ScriptCredential.credential_hash",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.ScriptCredential.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingHash",
"url":15,
"doc":"Indicates that the stake of this address is controlled by the associated credential"
},
{
"ref":"hebi.ledger.api_v2.StakingHash.value",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingHash.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingPtr",
"url":15,
"doc":"Indicates that the stake of this address is controlled by the associated pointer. In an address, a chain pointer refers to a point of the chain containing a stake key registration certificate. A point is identified by the 3 coordinates in this object."
},
{
"ref":"hebi.ledger.api_v2.StakingPtr.slot_no",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingPtr.tx_index",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingPtr.cert_index",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.StakingPtr.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.NoStakingCredential",
"url":15,
"doc":"Indicates that this address has no staking credentials. Its funds can not be delegated."
},
{
"ref":"hebi.ledger.api_v2.NoStakingCredential.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeStakingCredential",
"url":15,
"doc":"Indicates that this address has staking credentials. Its funds can be delegated by the credentialed user."
},
{
"ref":"hebi.ledger.api_v2.SomeStakingCredential.staking_credential",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeStakingCredential.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Address",
"url":15,
"doc":"A Shelley address, consisting of a payment and staking credential"
},
{
"ref":"hebi.ledger.api_v2.Address.payment_credential",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Address.staking_credential",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeDatumHash",
"url":15,
"doc":"Indicates that there is a datum associated with this output, which has the given hash."
},
{
"ref":"hebi.ledger.api_v2.SomeDatumHash.datum_hash",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeDatumHash.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeScriptHash",
"url":15,
"doc":"Indicates that there is a script associated with this output, which has the given hash."
},
{
"ref":"hebi.ledger.api_v2.SomeScriptHash.script_hash",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeScriptHash.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.NoOutputDatum",
"url":15,
"doc":"Indicates that there is no datum associated with an output"
},
{
"ref":"hebi.ledger.api_v2.NoOutputDatum.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatumHash",
"url":15,
"doc":"Indicates that there is an datum associated with an output, which has the attached hash"
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatumHash.datum_hash",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatumHash.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatum",
"url":15,
"doc":"Indicates that there is an datum associated with an output, which is inlined and equal to the attached datum"
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatum.datum",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.SomeOutputDatum.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.NoScriptHash",
"url":15,
"doc":"Indicates that there is no script associated with an output"
},
{
"ref":"hebi.ledger.api_v2.NoScriptHash.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOut",
"url":15,
"doc":"The plutus representation of an transaction output, consisting of - address: address owning this output - value: tokens associated with this output - datum: datum associated with this output - reference_script: reference script associated with this output"
},
{
"ref":"hebi.ledger.api_v2.TxOut.address",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOut.value",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOut.datum",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxOut.reference_script",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInInfo",
"url":15,
"doc":"The plutus representation of an transaction output, that is consumed by the transaction."
},
{
"ref":"hebi.ledger.api_v2.TxInInfo.out_ref",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInInfo.resolved",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegRegKey",
"url":15,
"doc":"DCertDelegRegKey(value: Union[hebi.ledger.api_v2.StakingHash, hebi.ledger.api_v2.StakingPtr])"
},
{
"ref":"hebi.ledger.api_v2.DCertDelegRegKey.value",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegRegKey.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDeRegKey",
"url":15,
"doc":"DCertDelegDeRegKey(value: Union[hebi.ledger.api_v2.StakingHash, hebi.ledger.api_v2.StakingPtr])"
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDeRegKey.value",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDeRegKey.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDelegate",
"url":15,
"doc":"DCertDelegDelegate(delegator: Union[hebi.ledger.api_v2.StakingHash, hebi.ledger.api_v2.StakingPtr], delegatee: bytes)"
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDelegate.delegator",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDelegate.delegatee",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertDelegDelegate.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRegister",
"url":15,
"doc":"DCertPoolRegister(pool_id: bytes, pool_vfr: bytes)"
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRegister.pool_id",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRegister.pool_vfr",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRegister.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRetire",
"url":15,
"doc":"DCertPoolRetire(retirement_certificate: bytes, epoch: int)"
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRetire.retirement_certificate",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRetire.epoch",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertPoolRetire.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertGenesis",
"url":15,
"doc":"DCertGenesis()"
},
{
"ref":"hebi.ledger.api_v2.DCertGenesis.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.DCertMir",
"url":15,
"doc":"DCertMir()"
},
{
"ref":"hebi.ledger.api_v2.DCertMir.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.NegInfPOSIXTime",
"url":15,
"doc":"Negative infinite POSIX time, used to indicate that there is no lower bound for the execution of this transaction"
},
{
"ref":"hebi.ledger.api_v2.NegInfPOSIXTime.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.FinitePOSIXTime",
"url":15,
"doc":"Finite POSIX time, used to indicate that there is a lower or upper bound for the execution of this transaction"
},
{
"ref":"hebi.ledger.api_v2.FinitePOSIXTime.time",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.FinitePOSIXTime.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.PosInfPOSIXTime",
"url":15,
"doc":"Infinite POSIX time, used to indicate that there is no upper bound for the execution of this transaction"
},
{
"ref":"hebi.ledger.api_v2.PosInfPOSIXTime.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.UpperBoundPOSIXTime",
"url":15,
"doc":"Upper bound for the execution of this transaction"
},
{
"ref":"hebi.ledger.api_v2.UpperBoundPOSIXTime.limit",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.UpperBoundPOSIXTime.closed",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.UpperBoundPOSIXTime.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.LowerBoundPOSIXTime",
"url":15,
"doc":"Lower bound for the execution of this transaction"
},
{
"ref":"hebi.ledger.api_v2.LowerBoundPOSIXTime.limit",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.LowerBoundPOSIXTime.closed",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.LowerBoundPOSIXTime.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.POSIXTimeRange",
"url":15,
"doc":"Time range in which this transaction can be executed"
},
{
"ref":"hebi.ledger.api_v2.POSIXTimeRange.lower_bound",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.POSIXTimeRange.upper_bound",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Minting",
"url":15,
"doc":"Script purpose indicating that the given policy id is being minted or burned"
},
{
"ref":"hebi.ledger.api_v2.Minting.policy_id",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Minting.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Spending",
"url":15,
"doc":"Script purpose indicating that the given transaction output is being spent, which is owned by the invoked contract"
},
{
"ref":"hebi.ledger.api_v2.Spending.tx_out_ref",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Spending.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Rewarding",
"url":15,
"doc":"Rewarding(staking_credential: Union[hebi.ledger.api_v2.StakingHash, hebi.ledger.api_v2.StakingPtr])"
},
{
"ref":"hebi.ledger.api_v2.Rewarding.staking_credential",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Rewarding.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Certifying",
"url":15,
"doc":"Certifying(d_cert: Union[hebi.ledger.api_v2.DCertDelegRegKey, hebi.ledger.api_v2.DCertDelegDeRegKey, hebi.ledger.api_v2.DCertDelegDelegate, hebi.ledger.api_v2.DCertPoolRegister, hebi.ledger.api_v2.DCertPoolRetire, hebi.ledger.api_v2.DCertGenesis, hebi.ledger.api_v2.DCertMir])"
},
{
"ref":"hebi.ledger.api_v2.Certifying.d_cert",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.Certifying.CONSTR_ID",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo",
"url":15,
"doc":"A complex agglomeration of everything that could be of interest to the executed script, regarding the transaction that invoked the script"
},
{
"ref":"hebi.ledger.api_v2.TxInfo.inputs",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.reference_inputs",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.outputs",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.fee",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.mint",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.dcert",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.wdrl",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.valid_range",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.signatories",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.redeemers",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.data",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.TxInfo.id",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.ScriptContext",
"url":15,
"doc":"Auxiliary information about the transaction and reason for invocation of the called script."
},
{
"ref":"hebi.ledger.api_v2.ScriptContext.tx_info",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.api_v2.ScriptContext.purpose",
"url":15,
"doc":""
},
{
"ref":"hebi.ledger.interval",
"url":16,
"doc":""
},
{
"ref":"hebi.ledger.interval.compare",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.compare_extended_helper",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.compare_extended",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.get_bool",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.compare_upper_bound",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.compare_lower_bound",
"url":16,
"doc":"",
"func":1
},
{
"ref":"hebi.ledger.interval.contains",
"url":16,
"doc":"Returns True if the interval  b is entirely contained in  a .",
"func":1
},
{
"ref":"hebi.ledger.interval.make_range",
"url":16,
"doc":"Create a bounded interval from the given time  lower_bound up to the given  upper_bound , including the given time",
"func":1
},
{
"ref":"hebi.ledger.interval.make_from",
"url":16,
"doc":"Create a bounded interval from the given time  lower_bound up to infinity, including the given time",
"func":1
},
{
"ref":"hebi.ledger.interval.make_to",
"url":16,
"doc":"Create a bounded interval from negative infinity up to the given  upper_bound , including the given time",
"func":1
},
{
"ref":"hebi.optimize",
"url":17,
"doc":""
},
{
"ref":"hebi.optimize.optimize_varlen",
"url":18,
"doc":""
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector",
"url":18,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector.step",
"url":18,
"doc":""
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector.visit_Name",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector.visit_ClassDef",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector.visit_FunctionDef",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.NameCollector.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.bs_from_int",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen",
"url":18,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.step",
"url":18,
"doc":""
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.varmap",
"url":18,
"doc":""
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.visit_Module",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.visit_Name",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.visit_ClassDef",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.visit_FunctionDef",
"url":18,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_varlen.OptimizeVarlen.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_pass",
"url":20,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_pass.OptimizeRemovePass",
"url":20,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.optimize.optimize_remove_pass.OptimizeRemovePass.step",
"url":20,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_pass.OptimizeRemovePass.visit_Pass",
"url":20,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_pass.OptimizeRemovePass.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_comments",
"url":21,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants",
"url":21,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.step",
"url":21,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.visit_Expr",
"url":21,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_comments.OptimizeRemoveDeadconstants.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector",
"url":22,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector.step",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_Name",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_ClassDef",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_FunctionDef",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor",
"url":22,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.step",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.generic_visit",
"url":22,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Lambda",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Constant",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_RawPlutoExpr",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Name",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars",
"url":22,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.step",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.loaded_vars",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed_avail_names",
"url":22,
"doc":""
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.enter_scope",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.exit_scope",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.set_guaranteed",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Module",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_If",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_While",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_For",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Assign",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_AnnAssign",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_ClassDef",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_FunctionDef",
"url":22,
"doc":"",
"func":1
},
{
"ref":"hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.compiler",
"url":23,
"doc":""
},
{
"ref":"hebi.compiler.wrap_validator_double_function",
"url":23,
"doc":"Wraps the validator function to enable a double function as minting script pass_through defines how many parameters x would normally take and should be passed through to x",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler",
"url":23,
"doc":"Expects a TypedAST and returns UPLC/Pluto like code"
},
{
"ref":"hebi.compiler.UPLCCompiler.step",
"url":23,
"doc":""
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_sequence",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_BinOp",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_BoolOp",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_UnaryOp",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Compare",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Module",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Constant",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_NoneType",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Assign",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_AnnAssign",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Name",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Expr",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Call",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_FunctionDef",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_If",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Return",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Pass",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Subscript",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Tuple",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_ClassDef",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Attribute",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Assert",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_RawPlutoExpr",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_List",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_Dict",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_IfExp",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit_ListComp",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.generic_visit",
"url":23,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"hebi.compiler.UPLCCompiler.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.compiler.compile",
"url":23,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite",
"url":24,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_remove_type_stuff",
"url":25,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff",
"url":25,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.step",
"url":25,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.visit_Assign",
"url":25,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_remove_type_stuff.RewriteRemoveTypeStuff.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment",
"url":26,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment",
"url":26,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.step",
"url":26,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.avail_names",
"url":26,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.avail",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.in_current_scope",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.enter_scope",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.exit_scope",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.set_avail",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_Module",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_If",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_Assign",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_AnnAssign",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_ClassDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit_FunctionDef",
"url":26,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_duplicate_assignment.RewriteDuplicateAssignment.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_typing",
"url":27,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping",
"url":27,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping.step",
"url":27,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping.imports_typing",
"url":27,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping.visit_ImportFrom",
"url":27,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping.visit_ClassDef",
"url":27,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_typing.RewriteImportTyping.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_inject_builtin_constr",
"url":28,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr",
"url":28,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.step",
"url":28,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.visit_Module",
"url":28,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_inject_builtin_constr.RewriteInjectBuiltinsConstr.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses",
"url":29,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses",
"url":29,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.step",
"url":29,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.imports_dataclasses",
"url":29,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit_ImportFrom",
"url":29,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit_ClassDef",
"url":29,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_dataclasses.RewriteImportDataclasses.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_subscript38",
"url":30,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_subscript38.RewriteSubscript38",
"url":30,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_subscript38.RewriteSubscript38.step",
"url":30,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_subscript38.RewriteSubscript38.visit_Index",
"url":30,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_subscript38.RewriteSubscript38.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites",
"url":31,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites.ForbiddenOverwriteError",
"url":31,
"doc":"Inappropriate argument value (of correct type)."
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites",
"url":31,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.step",
"url":31,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.visit_Name",
"url":31,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_forbidden_overwrites.RewriteForbiddenOverwrites.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_inject_builtins",
"url":32,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins",
"url":32,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.step",
"url":32,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.visit_Module",
"url":32,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_inject_builtins.RewriteInjectBuiltins.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata",
"url":33,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData",
"url":33,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.step",
"url":33,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.imports_plutus_data",
"url":33,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit_ImportFrom",
"url":33,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit_ClassDef",
"url":33,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_plutusdata.RewriteImportPlutusData.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_zero_ary",
"url":34,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_zero_ary.RewriteZeroAry",
"url":34,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_zero_ary.RewriteZeroAry.step",
"url":34,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_zero_ary.RewriteZeroAry.visit_FunctionDef",
"url":34,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_zero_ary.RewriteZeroAry.visit_Call",
"url":34,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_zero_ary.RewriteZeroAry.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType",
"url":35,
"doc":"A pseudo class that is the result of python hash functions that need a 'digest' call"
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType.attribute_type",
"url":35,
"doc":"The types of the named attributes of this class",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType.attribute",
"url":35,
"doc":"The attributes of this class. Needs to be a lambda that expects as first argument the object itself",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType.constr_type",
"url":1,
"doc":"The type of the constructor for this class",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType.constr",
"url":1,
"doc":"The constructor for this class",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.HashType.cmp",
"url":1,
"doc":"The implementation of comparing this type to type o via operator op. Returns a lambda that expects as first argument the object itself and as second the comparison.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.PythonHashlib",
"url":35,
"doc":"An enumeration."
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.PythonHashlib.sha256",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.PythonHashlib.sha3_256",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.PythonHashlib.blake2b",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.RewriteImportHashlib",
"url":35,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.RewriteImportHashlib.step",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.RewriteImportHashlib.imports_hashlib",
"url":35,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.RewriteImportHashlib.visit_ImportFrom",
"url":35,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import_hashlib.RewriteImportHashlib.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign",
"url":36,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign",
"url":36,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign.step",
"url":36,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign.unique_id",
"url":36,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit_Assign",
"url":36,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit_For",
"url":36,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_tuple_assign.RewriteTupleAssign.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import",
"url":37,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import.import_module",
"url":37,
"doc":"An approximate implementation of import.",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import.RewriteImport",
"url":37,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.rewrite.rewrite_import.RewriteImport.step",
"url":37,
"doc":""
},
{
"ref":"hebi.rewrite.rewrite_import.RewriteImport.visit_ImportFrom",
"url":37,
"doc":"",
"func":1
},
{
"ref":"hebi.rewrite.rewrite_import.RewriteImport.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.std",
"url":38,
"doc":""
},
{
"ref":"hebi.std.math",
"url":39,
"doc":"An implementation of some math operations in opshin"
},
{
"ref":"hebi.std.math.gcd",
"url":39,
"doc":"",
"func":1
},
{
"ref":"hebi.std.math.sign",
"url":39,
"doc":"",
"func":1
},
{
"ref":"hebi.std.math.unsigned_int_from_bytes_big",
"url":39,
"doc":"Converts a bytestring into the corresponding integer, big/network byteorder, unsigned",
"func":1
},
{
"ref":"hebi.std.fractions",
"url":40,
"doc":"An implementation of fractions in opshin This does not maintain smallest possible notation invariants for the sake of efficiency - the user has full control over when to normalize the fractions and should do so using norm_fraction"
},
{
"ref":"hebi.std.fractions.Fraction",
"url":40,
"doc":"Fraction(numerator: int, denominator: int)"
},
{
"ref":"hebi.std.fractions.Fraction.numerator",
"url":40,
"doc":""
},
{
"ref":"hebi.std.fractions.Fraction.denominator",
"url":40,
"doc":""
},
{
"ref":"hebi.std.fractions.Fraction.CONSTR_ID",
"url":40,
"doc":""
},
{
"ref":"hebi.std.fractions.add_fraction",
"url":40,
"doc":"returns a + b",
"func":1
},
{
"ref":"hebi.std.fractions.neg_fraction",
"url":40,
"doc":"returns -a",
"func":1
},
{
"ref":"hebi.std.fractions.sub_fraction",
"url":40,
"doc":"returns a - b",
"func":1
},
{
"ref":"hebi.std.fractions.mul_fraction",
"url":40,
"doc":"returns a  b",
"func":1
},
{
"ref":"hebi.std.fractions.div_fraction",
"url":40,
"doc":"returns a / b",
"func":1
},
{
"ref":"hebi.std.fractions.norm_fraction",
"url":40,
"doc":"Restores the invariant that num/denom are in the smallest possible denomination and denominator > 0",
"func":1
},
{
"ref":"hebi.std.fractions.ge_fraction",
"url":40,
"doc":"returns a >= b",
"func":1
},
{
"ref":"hebi.std.fractions.le_fraction",
"url":40,
"doc":"returns a <= b",
"func":1
},
{
"ref":"hebi.std.fractions.eq_fraction",
"url":40,
"doc":"returns a  b",
"func":1
},
{
"ref":"hebi.std.fractions.lt_fraction",
"url":40,
"doc":"returns a < b",
"func":1
},
{
"ref":"hebi.std.fractions.gt_fraction",
"url":40,
"doc":"returns a > b",
"func":1
},
{
"ref":"hebi.type_inference",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.ReturnExtractor",
"url":41,
"doc":"Utility to find all Return statements in an AST subtree"
},
{
"ref":"hebi.type_inference.ReturnExtractor.visit_Return",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer",
"url":41,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.step",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.scopes",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.variable_type",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.enter_scope",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.exit_scope",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.set_variable_type",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.type_from_annotation",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_ClassDef",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Constant",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Tuple",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_List",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Dict",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Assign",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_AnnAssign",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_If",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_While",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_For",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Name",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Compare",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_arg",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_arguments",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_FunctionDef",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Module",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Expr",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_BinOp",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_BoolOp",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_UnaryOp",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Subscript",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Call",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Pass",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Return",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Attribute",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_Assert",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_RawPlutoExpr",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_IfExp",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_comprehension",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit_ListComp",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.generic_visit",
"url":41,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"hebi.type_inference.AggressiveTypeInferencer.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader",
"url":41,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.type_inference.RecordReader.name",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.RecordReader.constructor",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.RecordReader.attributes",
"url":41,
"doc":""
},
{
"ref":"hebi.type_inference.RecordReader.extract",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.visit_AnnAssign",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.visit_ClassDef",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.visit_Pass",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.visit_Assign",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.visit_Expr",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.type_inference.RecordReader.generic_visit",
"url":41,
"doc":"Called if no explicit visitor function exists for a node.",
"func":1
},
{
"ref":"hebi.type_inference.typed_ast",
"url":41,
"doc":"",
"func":1
},
{
"ref":"hebi.util",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn",
"url":19,
"doc":"An enumeration."
},
{
"ref":"hebi.util.PythonBuiltIn.all",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.any",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.abs",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.chr",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.breakpoint",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.hex",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.len",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.max",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.min",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.print",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.pow",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.oct",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.range",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.reversed",
"url":19,
"doc":""
},
{
"ref":"hebi.util.PythonBuiltIn.sum",
"url":19,
"doc":""
},
{
"ref":"hebi.util.LenImpl",
"url":19,
"doc":""
},
{
"ref":"hebi.util.LenImpl.type_from_args",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.LenImpl.impl_from_args",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.ReversedImpl",
"url":19,
"doc":""
},
{
"ref":"hebi.util.ReversedImpl.type_from_args",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.ReversedImpl.impl_from_args",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.CompilerError",
"url":19,
"doc":"Common base class for all non-exit exceptions."
},
{
"ref":"hebi.util.CompilingNodeTransformer",
"url":19,
"doc":"A :class: NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes. The  NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is  None , the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place. Here is an example transformer that rewrites all occurrences of name lookups ( foo ) to  data['foo']  class RewriteName(NodeTransformer): def visit_Name(self, node): return Subscript( value=Name(id='data', ctx=Load( , slice=Index(value=Str(s=node.id , ctx=node.ctx ) Keep in mind that if the node you're operating on has child nodes you must either transform the child nodes yourself or call the :meth: generic_visit method for the node first. For nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node. Usually you use the transformer like this node = YourTransformer().visit(node)"
},
{
"ref":"hebi.util.CompilingNodeTransformer.step",
"url":19,
"doc":""
},
{
"ref":"hebi.util.CompilingNodeTransformer.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.util.CompilingNodeVisitor",
"url":19,
"doc":"A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found. This function may return a value which is forwarded by the  visit method. This class is meant to be subclassed, with the subclass adding visitor methods. Per default the visitor functions for the nodes are  'visit_' + class name of the node. So a  TryFinally node visit function would be  visit_TryFinally . This behavior can be changed by overriding the  visit method. If no visitor function exists for a node (return value  None ) the  generic_visit visitor is used instead. Don't use the  NodeVisitor if you want to apply changes to nodes during traversing. For this a special visitor exists ( NodeTransformer ) that allows modifications."
},
{
"ref":"hebi.util.CompilingNodeVisitor.step",
"url":19,
"doc":""
},
{
"ref":"hebi.util.CompilingNodeVisitor.visit",
"url":19,
"doc":"Visit a node.",
"func":1
},
{
"ref":"hebi.util.data_from_json",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.datum_to_cbor",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.util.datum_to_json",
"url":19,
"doc":"",
"func":1
},
{
"ref":"hebi.prelude",
"url":42,
"doc":""
},
{
"ref":"hebi.prelude.Token",
"url":42,
"doc":"A token, represented by policy id and token name"
},
{
"ref":"hebi.prelude.Token.policy_id",
"url":42,
"doc":""
},
{
"ref":"hebi.prelude.Token.token_name",
"url":42,
"doc":""
},
{
"ref":"hebi.prelude.all_tokens_unlocked_from_address",
"url":42,
"doc":"Returns how many tokens of specified type are unlocked from given address",
"func":1
},
{
"ref":"hebi.prelude.all_tokens_locked_at_address_with_datum",
"url":42,
"doc":"Returns how many tokens of specified type are locked at then given address with the specified datum",
"func":1
},
{
"ref":"hebi.prelude.all_tokens_locked_at_address",
"url":42,
"doc":"Returns how many tokens of specified type are locked at the given address",
"func":1
},
{
"ref":"hebi.prelude.resolve_spent_utxo",
"url":42,
"doc":"Returns the UTxO whose spending should be validated",
"func":1
},
{
"ref":"hebi.prelude.resolve_datum_unsafe",
"url":42,
"doc":"Returns the datum attached to a given transaction output, independent of whether it was inlined or embedded. Raises an exception if no datum was attached.",
"func":1
},
{
"ref":"hebi.prelude.resolve_datum",
"url":42,
"doc":"Returns SomeOutputDatum with the datum attached to a given transaction output, independent of whether it was inlined or embedded, if there was an attached datum. Otherwise it returns NoOutputDatum.",
"func":1
}
]