<!doctype html>
<html lang="en">
<head>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<link rel="icon" href="https://raw.githubusercontent.com/OpShin/hebi/dev/docs/hebi_32.png" sizes="32x32" type="image/png">
<title>hebi.compiler API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<style>
.github-corner:hover .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
0%,
100% {
transform: rotate(0)
}
20%,
60% {
transform: rotate(-25deg)
}
40%,
80% {
transform: rotate(10deg)
}
}
@media (max-width:500px) {
.github-corner:hover .octo-arm {
animation: none
}
.github-corner .octo-arm {
animation: octocat-wave 560ms ease-in-out
}
}
</style>
<a href="https://github.com/opshin/hebi" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250"
style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z">
</path>
<path
d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path
d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
fill="currentColor" class="octo-body"></path>
</svg>
</a>
<article id="content">
<header>
<h1 class="title">Module <code>hebi.compiler</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from logging import getLogger
from ast import fix_missing_locations

from .optimize.optimize_remove_comments import OptimizeRemoveDeadconstants
from .rewrite.rewrite_forbidden_overwrites import RewriteForbiddenOverwrites
from .rewrite.rewrite_guaranteed_variables import RewriteGuaranteedVariables
from .rewrite.rewrite_import import RewriteImport
from .rewrite.rewrite_import_dataclasses import RewriteImportDataclasses
from .rewrite.rewrite_import_hashlib import RewriteImportHashlib
from .rewrite.rewrite_import_plutusdata import RewriteImportPlutusData
from .rewrite.rewrite_import_typing import RewriteImportTyping
from .rewrite.rewrite_inject_builtins import RewriteInjectBuiltins
from .rewrite.rewrite_inject_builtin_constr import RewriteInjectBuiltinsConstr
from .rewrite.rewrite_remove_type_stuff import RewriteRemoveTypeStuff
from .rewrite.rewrite_subscript38 import RewriteSubscript38
from .rewrite.rewrite_tuple_assign import RewriteTupleAssign
from .rewrite.rewrite_duplicate_assignment import RewriteDuplicateAssignment
from .rewrite.rewrite_zero_ary import RewriteZeroAry
from .optimize.optimize_remove_pass import OptimizeRemovePass
from .optimize.optimize_remove_deadvars import OptimizeRemoveDeadvars
from .type_inference import *
from .util import CompilingNodeTransformer, PowImpl
from .typed_ast import transform_ext_params_map, transform_output_map, RawPlutoExpr


_LOGGER = logging.getLogger(__name__)

BinOpMap = {
    Add: {
        IntegerInstanceType: {
            IntegerInstanceType: plt.AddInteger,
        },
        ByteStringInstanceType: {
            ByteStringInstanceType: plt.AppendByteString,
        },
        StringInstanceType: {
            StringInstanceType: plt.AppendString,
        },
    },
    Sub: {
        IntegerInstanceType: {
            IntegerInstanceType: plt.SubtractInteger,
        }
    },
    Mult: {
        IntegerInstanceType: {
            IntegerInstanceType: plt.MultiplyInteger,
        }
    },
    FloorDiv: {
        IntegerInstanceType: {
            IntegerInstanceType: plt.DivideInteger,
        }
    },
    Mod: {
        IntegerInstanceType: {
            IntegerInstanceType: plt.ModInteger,
        }
    },
    Pow: {
        IntegerInstanceType: {
            IntegerInstanceType: lambda x, y: plt.Apply(plt.RecFun(PowImpl), x, y),
        }
    },
}

BoolOpMap = {
    And: plt.And,
    Or: plt.Or,
}

UnaryOpMap = {
    Not: {BoolInstanceType: plt.Not},
    USub: {IntegerInstanceType: lambda x: plt.SubtractInteger(plt.Integer(0), x)},
}

ConstantMap = {
    str: plt.Text,
    bytes: lambda x: plt.ByteString(x),
    int: lambda x: plt.Integer(x),
    bool: plt.Bool,
    type(None): lambda _: plt.Unit(),
}


def wrap_validator_double_function(x: plt.AST, pass_through: int = 0):
    &#34;&#34;&#34;
    Wraps the validator function to enable a double function as minting script

    pass_through defines how many parameters x would normally take and should be passed through to x
    &#34;&#34;&#34;
    return plt.Lambda(
        [f&#34;v{i}&#34; for i in range(pass_through)] + [&#34;a0&#34;, &#34;a1&#34;],
        plt.Let(
            [(&#34;p&#34;, plt.Apply(x, *(plt.Var(f&#34;v{i}&#34;) for i in range(pass_through))))],
            plt.Ite(
                # if the second argument has constructor 0 = script context
                plt.DelayedChooseData(
                    plt.Var(&#34;a1&#34;),
                    plt.EqualsInteger(plt.Constructor(plt.Var(&#34;a1&#34;)), plt.Integer(0)),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                ),
                # call the validator with a0, a1, and plug in Unit for data
                plt.Apply(plt.Var(&#34;p&#34;), plt.Unit(), plt.Var(&#34;a0&#34;), plt.Var(&#34;a1&#34;)),
                # else call the validator with a0, a1 and return (now partially bound)
                plt.Apply(plt.Var(&#34;p&#34;), plt.Var(&#34;a0&#34;), plt.Var(&#34;a1&#34;)),
            ),
        ),
    )


class UPLCCompiler(CompilingNodeTransformer):
    &#34;&#34;&#34;
    Expects a TypedAST and returns UPLC/Pluto like code
    &#34;&#34;&#34;

    step = &#34;Compiling python statements to UPLC&#34;

    def __init__(self, force_three_params=False, validator_function_name=&#34;validator&#34;):
        self.force_three_params = force_three_params
        self.validator_function_name = validator_function_name

    def visit_sequence(
        self, node_seq: typing.List[typedstmt]
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        def g(s: plt.AST):
            for n in reversed(node_seq):
                compiled_stmt = self.visit(n)
                s = compiled_stmt(s)
            return s

        return g

    def visit_BinOp(self, node: TypedBinOp) -&gt; plt.AST:
        opmap = BinOpMap.get(type(node.op))
        if opmap is None:
            raise NotImplementedError(f&#34;Operation {node.op} is not implemented&#34;)
        opmap2 = opmap.get(node.left.typ)
        if opmap2 is None:
            raise NotImplementedError(
                f&#34;Operation {node.op} is not implemented for left type {node.left.typ}&#34;
            )
        op = opmap2.get(node.right.typ)
        if opmap2 is None:
            raise NotImplementedError(
                f&#34;Operation {node.op} is not implemented for left type {node.left.typ} and right type {node.right.typ}&#34;
            )
        return op(self.visit(node.left), self.visit(node.right))

    def visit_BoolOp(self, node: TypedBoolOp) -&gt; plt.AST:
        op = BoolOpMap.get(type(node.op))
        assert len(node.values) &gt;= 2, &#34;Need to compare at least to values&#34;
        ops = op(
            self.visit(node.values[0]),
            self.visit(node.values[1]),
        )
        for v in node.values[2:]:
            ops = op(ops, self.visit(v))
        return ops

    def visit_UnaryOp(self, node: TypedUnaryOp) -&gt; plt.AST:
        opmap = UnaryOpMap.get(type(node.op))
        assert opmap is not None, f&#34;Operator {type(node.op)} is not supported&#34;
        op = opmap.get(node.operand.typ)
        assert (
            op is not None
        ), f&#34;Operator {type(node.op)} is not supported for type {node.operand.typ}&#34;
        return op(self.visit(node.operand))

    def visit_Compare(self, node: TypedCompare) -&gt; plt.AST:
        assert len(node.ops) == 1, &#34;Only single comparisons are supported&#34;
        assert len(node.comparators) == 1, &#34;Only single comparisons are supported&#34;
        cmpop = node.ops[0]
        comparator = node.comparators[0].typ
        op = node.left.typ.cmp(cmpop, comparator)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.comparators[0]),
        )

    def visit_Module(self, node: TypedModule) -&gt; plt.AST:
        # find main function
        # TODO can use more sophisiticated procedure here i.e. functions marked by comment
        main_fun: typing.Optional[InstanceType] = None
        for s in node.body:
            if isinstance(s, FunctionDef) and s.name == self.validator_function_name:
                main_fun = s
        assert (
            main_fun is not None
        ), f&#34;Could not find function named {self.validator_function_name}&#34;
        main_fun_typ: FunctionType = main_fun.typ.typ
        assert isinstance(
            main_fun_typ, FunctionType
        ), f&#34;Variable named {self.validator_function_name} is not of type function&#34;

        # check if this is a contract written to double function
        enable_double_func_mint_spend = False
        if len(main_fun_typ.argtyps) &gt;= 3 and self.force_three_params:
            # check if is possible
            second_last_arg = main_fun_typ.argtyps[-2]
            assert isinstance(
                second_last_arg, InstanceType
            ), &#34;Can not pass Class into validator&#34;
            if isinstance(second_last_arg.typ, UnionType):
                possible_types = second_last_arg.typ.typs
            else:
                possible_types = [second_last_arg.typ]
            if any(isinstance(t, UnitType) for t in possible_types):
                _LOGGER.warning(
                    &#34;The redeemer is annotated to be &#39;None&#39;. This value is usually encoded in PlutusData with constructor id 0 and no fields. If you want the script to double function as minting and spending script, annotate the second argument with &#39;NoRedeemer&#39;.&#34;
                )
            enable_double_func_mint_spend = not any(
                (isinstance(t, RecordType) and t.record.constructor == 0)
                or isinstance(t, UnitType)
                for t in possible_types
            )
            if not enable_double_func_mint_spend:
                _LOGGER.warning(
                    &#34;The second argument to the validator function potentially has constructor id 0. The validator will not be able to double function as minting script and spending script.&#34;
                )

        body = node.body + [
            TypedReturn(
                value=Name(
                    id=self.validator_function_name,
                    typ=InstanceType(main_fun_typ),
                    ctx=Load(),
                ),
                typ=InstanceType(main_fun_typ),
            )
        ]

        validator = plt.Lambda(
            [f&#34;p{i}&#34; for i, _ in enumerate(main_fun_typ.argtyps)],
            transform_output_map(main_fun_typ.rettyp)(
                plt.Let(
                    [
                        (
                            &#34;val&#34;,
                            self.visit_sequence(body)(
                                plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                            ),
                        ),
                    ],
                    plt.Apply(
                        plt.Var(&#34;val&#34;),
                        plt.Var(&#34;val&#34;),
                        *[
                            transform_ext_params_map(a)(plt.Var(f&#34;p{i}&#34;))
                            for i, a in enumerate(main_fun_typ.argtyps)
                        ],
                    ),
                ),
            ),
        )
        if enable_double_func_mint_spend:
            validator = wrap_validator_double_function(
                validator, pass_through=len(main_fun_typ.argtyps) - 3
            )
        elif self.force_three_params:
            # Error if the double function is enforced but not possible
            raise RuntimeError(
                &#34;The contract can not always detect if it was passed three or two parameters on-chain.&#34;
            )
        cp = plt.Program((1, 0, 0), validator)
        return cp

    def visit_Constant(self, node: TypedConstant) -&gt; plt.AST:
        plt_type = ConstantMap.get(type(node.value))
        if plt_type is None:
            raise NotImplementedError(
                f&#34;Constants of type {type(node.value)} are not supported&#34;
            )
        return plt_type(node.value)

    def visit_NoneType(self, _: typing.Optional[typing.Any]) -&gt; plt.AST:
        return plt.Unit()

    def visit_Assign(self, node: TypedAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
        assert (
            len(node.targets) == 1
        ), &#34;Assignments to more than one variable not supported yet&#34;
        assert isinstance(
            node.targets[0], Name
        ), &#34;Assignments to other things then names are not supported&#34;
        compiled_e = self.visit(node.value)
        varname = node.targets[0].id
        return lambda x: plt.Let([(varname, compiled_e)], x)

    def visit_AnnAssign(self, node: AnnAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
        assert isinstance(
            node.target, Name
        ), &#34;Assignments to other things than names are not supported&#34;
        assert isinstance(
            node.target.typ, InstanceType
        ), &#34;Can only assign instances to instances&#34;
        compiled_e = self.visit(node.value)
        # (\{STATEMONAD} -&gt; (\x -&gt; if (x ==b {self.visit(node.targets[0])}) then ({compiled_e} {STATEMONAD}) else ({STATEMONAD} x)))
        val = compiled_e
        if isinstance(node.value.typ, InstanceType) and isinstance(
            node.value.typ.typ, AnyType
        ):
            # we need to map this as it will originate from PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to builtin values
            val = transform_ext_params_map(node.target.typ)(val)
        if isinstance(node.target.typ, InstanceType) and isinstance(
            node.target.typ.typ, AnyType
        ):
            # we need to map this back as it will be treated as PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to from builtin values
            val = transform_output_map(node.value.typ)(val)
        return lambda x: plt.Let([(node.target.id, val)], x)

    def visit_Name(self, node: TypedName) -&gt; plt.AST:
        # depending on load or store context, return the value of the variable or its name
        if not isinstance(node.ctx, Load):
            raise NotImplementedError(f&#34;Context {node.ctx} not supported&#34;)
        if isinstance(node.typ, ClassType):
            # if this is not an instance but a class, call the constructor
            return node.typ.constr()
        return plt.Var(node.id)

    def visit_Expr(self, node: TypedExpr) -&gt; typing.Callable[[plt.AST], plt.AST]:
        # we exploit UPLCs eager evaluation here
        # the expression is computed even though its value is eventually discarded
        # Note this really only makes sense for Trace
        # we use an invalid name here to avoid conflicts
        return lambda x: plt.Apply(plt.Lambda([&#34;0&#34;], x), self.visit(node.value))

    def visit_Call(self, node: TypedCall) -&gt; plt.AST:
        # compiled_args = &#34; &#34;.join(f&#34;({self.visit(a)} {STATEMONAD})&#34; for a in node.args)
        # return rf&#34;(\{STATEMONAD} -&gt; ({self.visit(node.func)} {compiled_args})&#34;
        # TODO function is actually not of type polymorphic function type here anymore
        if isinstance(node.func.typ, PolymorphicFunctionInstanceType):
            # edge case for weird builtins that are polymorphic
            func_plt = node.func.typ.polymorphic_function.impl_from_args(
                node.func.typ.typ.argtyps
            )
        else:
            func_plt = self.visit(node.func)
        args = []
        for a, t in zip(node.args, node.func.typ.typ.argtyps):
            assert isinstance(t, InstanceType)
            # pass in all arguments evaluated with the statemonad
            a_int = self.visit(a)
            if isinstance(t.typ, AnyType):
                # if the function expects input of generic type data, wrap data before passing it inside
                a_int = transform_output_map(a.typ)(a_int)
            args.append(a_int)
        return plt.Apply(
            plt.RecFun(func_plt),
            *args,
        )

    def visit_FunctionDef(
        self, node: TypedFunctionDef
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        body = node.body.copy()
        # defaults to returning None if there is no return statement
        if node.typ.typ.rettyp.typ == AnyType():
            ret_val = plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
        else:
            ret_val = plt.Unit()
        compiled_body = self.visit_sequence(body)(ret_val)
        return lambda x: plt.Let(
            [
                (
                    node.name,
                    plt.Lambda(
                        [node.name] + [a.arg for a in node.args.args],
                        compiled_body,
                    ),
                )
            ],
            x,
        )

    def visit_If(self, node: TypedIf) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Ite(
            self.visit(node.test),
            self.visit_sequence(node.body)(x),
            self.visit_sequence(node.orelse)(x),
        )

    def visit_Return(self, node: TypedReturn) -&gt; typing.Callable[[plt.AST], plt.AST]:
        # Throw away the term we were passed, this is going to be the last!
        compiled_return = self.visit(node.value)
        if isinstance(node.typ.typ, AnyType):
            # if the function returns generic data, wrap the function return value
            compiled_return = transform_output_map(node.value.typ)(compiled_return)
        return lambda _: compiled_return

    def visit_Pass(self, node: TypedPass) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: x

    def visit_Subscript(self, node: TypedSubscript) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access elements of instances, not classes&#34;
        if isinstance(node.value.typ.typ, TupleType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for tuples is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for tuples is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += len(node.value.typ.typ.typs)
            assert isinstance(node.ctx, Load), &#34;Tuples are read-only&#34;
            return plt.FunctionalTupleAccess(
                self.visit(node.value),
                index,
                len(node.value.typ.typ.typs),
            )
        if isinstance(node.value.typ.typ, PairType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for pairs is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for pairs is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += 2
            assert isinstance(node.ctx, Load), &#34;Pairs are read-only&#34;
            assert (
                0 &lt;= index &lt; 2
            ), f&#34;Pairs only have 2 elements, index should be 0 or 1, is {node.slice.value}&#34;
            member_func = plt.FstPair if index == 0 else plt.SndPair
            # the content of pairs is always Data, so we need to unwrap
            member_typ = node.typ
            return transform_ext_params_map(member_typ)(
                member_func(
                    self.visit(node.value),
                ),
            )
        if isinstance(node.value.typ.typ, ListType):
            assert (
                node.slice.typ == IntegerInstanceType
            ), &#34;Only single element list index access supported&#34;
            return plt.Let(
                [
                    (&#34;l&#34;, self.visit(node.value)),
                    (
                        &#34;raw_i&#34;,
                        self.visit(node.slice),
                    ),
                    (
                        &#34;i&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                            plt.AddInteger(
                                plt.Var(&#34;raw_i&#34;), plt.LengthList(plt.Var(&#34;l&#34;))
                            ),
                            plt.Var(&#34;raw_i&#34;),
                        ),
                    ),
                ],
                plt.IndexAccessList(plt.Var(&#34;l&#34;), plt.Var(&#34;i&#34;)),
            )
        elif isinstance(node.value.typ.typ, DictType):
            dict_typ = node.value.typ.typ
            if not isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;key&#34;,
                            self.visit(node.slice),
                        )
                    ],
                    transform_ext_params_map(dict_typ.value_typ)(
                        plt.SndPair(
                            plt.FindList(
                                self.visit(node.value),
                                plt.Lambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        transform_output_map(dict_typ.key_typ)(
                                            plt.Var(&#34;key&#34;)
                                        ),
                                        plt.FstPair(plt.Var(&#34;x&#34;)),
                                    ),
                                ),
                                plt.TraceError(&#34;KeyError&#34;),
                            ),
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, ByteStringType):
            if not isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_ix&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;ix&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_ix&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_ix&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_ix&#34;),
                            ),
                        ),
                    ],
                    plt.IndexByteString(plt.Var(&#34;bs&#34;), plt.Var(&#34;ix&#34;)),
                )
            elif isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_i&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_j&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(plt.Var(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                plt.Var(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;i&#34;)),
                        plt.ByteString(b&#34;&#34;),
                        plt.SliceByteString(
                            plt.Var(&#34;drop&#34;),
                            plt.Var(&#34;take&#34;),
                            plt.Var(&#34;bs&#34;),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#39;Could not implement subscript &#34;{node.slice}&#34; of &#34;{node.value}&#34;&#39;
        )

    def visit_Tuple(self, node: TypedTuple) -&gt; plt.AST:
        return plt.FunctionalTuple(*(self.visit(e) for e in node.elts))

    def visit_ClassDef(
        self, node: TypedClassDef
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Let([(node.name, node.class_typ.constr())], x)

    def visit_Attribute(self, node: TypedAttribute) -&gt; plt.AST:
        assert isinstance(
            node.typ, InstanceType
        ), &#34;Can only access attributes of instances&#34;
        obj = self.visit(node.value)
        attr = node.value.typ.attribute(node.attr)
        return plt.Apply(attr, obj)

    def visit_Assert(self, node: TypedAssert) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Ite(
            self.visit(node.test),
            x,
            plt.Apply(
                plt.Error(),
                plt.Trace(self.visit(node.msg), plt.Unit())
                if node.msg is not None
                else plt.Unit(),
            ),
        )

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; plt.AST:
        return node.expr

    def visit_List(self, node: TypedList) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, ListType)
        l = empty_list(node.typ.typ.typ)
        for e in reversed(node.elts):
            l = plt.MkCons(self.visit(e), l)
        return l

    def visit_Dict(self, node: TypedDict) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, DictType)
        key_type = node.typ.typ.key_typ
        value_type = node.typ.typ.value_typ
        l = plt.EmptyDataPairList()
        for k, v in zip(node.keys, node.values):
            l = plt.MkCons(
                plt.MkPairData(
                    transform_output_map(key_type)(self.visit(k)),
                    transform_output_map(value_type)(self.visit(v)),
                ),
                l,
            )
        return l

    def visit_IfExp(self, node: TypedIfExp) -&gt; plt.AST:
        return plt.Ite(
            self.visit(node.test),
            self.visit(node.body),
            self.visit(node.orelse),
        )

    def visit_ListComp(self, node: TypedListComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = plt.Lambda(
            [gen.target.id],
            self.visit(node.elt),
        )
        empty_list_con = empty_list(node.elt.typ)
        if ifs is not None:
            filter_fun = plt.Lambda(
                [gen.target.id],
                ifs,
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def generic_visit(self, node: AST) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not compile {node}&#34;)


def compile(
    prog: AST,
    filename=None,
    force_three_params=False,
    validator_function_name=&#34;validator&#34;,
):
    rewrite_steps = [
        # Important to call this one first - it imports all further files
        RewriteImport(filename=filename),
        # Rewrites that simplify the python code
        RewriteSubscript38(),
        RewriteTupleAssign(),
        RewriteImportPlutusData(),
        RewriteImportHashlib(),
        RewriteImportTyping(),
        RewriteForbiddenOverwrites(),
        RewriteImportDataclasses(),
        RewriteInjectBuiltins(),
        RewriteDuplicateAssignment(),
        RewriteGuaranteedVariables(),
        # The type inference needs to be run after complex python operations were rewritten
        AggressiveTypeInferencer(),
        # Rewrites that circumvent the type inference or use its results
        RewriteZeroAry(),
        RewriteInjectBuiltinsConstr(),
        RewriteRemoveTypeStuff(),
    ]
    for s in rewrite_steps:
        prog = s.visit(prog)
        prog = fix_missing_locations(prog)

    # from here on raw uplc may occur, so we dont attempt to fix locations
    compile_pipeline = [
        # Apply optimizations
        OptimizeRemoveDeadvars(),
        OptimizeRemoveDeadconstants(),
        OptimizeRemovePass(),
        # the compiler runs last
        UPLCCompiler(
            force_three_params=force_three_params,
            validator_function_name=validator_function_name,
        ),
    ]
    for s in compile_pipeline:
        prog = s.visit(prog)

    return prog</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hebi.compiler.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>prog: _ast.AST, filename=None, force_three_params=False, validator_function_name='validator')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(
    prog: AST,
    filename=None,
    force_three_params=False,
    validator_function_name=&#34;validator&#34;,
):
    rewrite_steps = [
        # Important to call this one first - it imports all further files
        RewriteImport(filename=filename),
        # Rewrites that simplify the python code
        RewriteSubscript38(),
        RewriteTupleAssign(),
        RewriteImportPlutusData(),
        RewriteImportHashlib(),
        RewriteImportTyping(),
        RewriteForbiddenOverwrites(),
        RewriteImportDataclasses(),
        RewriteInjectBuiltins(),
        RewriteDuplicateAssignment(),
        RewriteGuaranteedVariables(),
        # The type inference needs to be run after complex python operations were rewritten
        AggressiveTypeInferencer(),
        # Rewrites that circumvent the type inference or use its results
        RewriteZeroAry(),
        RewriteInjectBuiltinsConstr(),
        RewriteRemoveTypeStuff(),
    ]
    for s in rewrite_steps:
        prog = s.visit(prog)
        prog = fix_missing_locations(prog)

    # from here on raw uplc may occur, so we dont attempt to fix locations
    compile_pipeline = [
        # Apply optimizations
        OptimizeRemoveDeadvars(),
        OptimizeRemoveDeadconstants(),
        OptimizeRemovePass(),
        # the compiler runs last
        UPLCCompiler(
            force_three_params=force_three_params,
            validator_function_name=validator_function_name,
        ),
    ]
    for s in compile_pipeline:
        prog = s.visit(prog)

    return prog</code></pre>
</details>
</dd>
<dt id="hebi.compiler.wrap_validator_double_function"><code class="name flex">
<span>def <span class="ident">wrap_validator_double_function</span></span>(<span>x: pluthon.pluthon_ast.AST, pass_through: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps the validator function to enable a double function as minting script</p>
<p>pass_through defines how many parameters x would normally take and should be passed through to x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_validator_double_function(x: plt.AST, pass_through: int = 0):
    &#34;&#34;&#34;
    Wraps the validator function to enable a double function as minting script

    pass_through defines how many parameters x would normally take and should be passed through to x
    &#34;&#34;&#34;
    return plt.Lambda(
        [f&#34;v{i}&#34; for i in range(pass_through)] + [&#34;a0&#34;, &#34;a1&#34;],
        plt.Let(
            [(&#34;p&#34;, plt.Apply(x, *(plt.Var(f&#34;v{i}&#34;) for i in range(pass_through))))],
            plt.Ite(
                # if the second argument has constructor 0 = script context
                plt.DelayedChooseData(
                    plt.Var(&#34;a1&#34;),
                    plt.EqualsInteger(plt.Constructor(plt.Var(&#34;a1&#34;)), plt.Integer(0)),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                    plt.Bool(False),
                ),
                # call the validator with a0, a1, and plug in Unit for data
                plt.Apply(plt.Var(&#34;p&#34;), plt.Unit(), plt.Var(&#34;a0&#34;), plt.Var(&#34;a1&#34;)),
                # else call the validator with a0, a1 and return (now partially bound)
                plt.Apply(plt.Var(&#34;p&#34;), plt.Var(&#34;a0&#34;), plt.Var(&#34;a1&#34;)),
            ),
        ),
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hebi.compiler.UPLCCompiler"><code class="flex name class">
<span>class <span class="ident">UPLCCompiler</span></span>
<span>(</span><span>force_three_params=False, validator_function_name='validator')</span>
</code></dt>
<dd>
<div class="desc"><p>Expects a TypedAST and returns UPLC/Pluto like code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UPLCCompiler(CompilingNodeTransformer):
    &#34;&#34;&#34;
    Expects a TypedAST and returns UPLC/Pluto like code
    &#34;&#34;&#34;

    step = &#34;Compiling python statements to UPLC&#34;

    def __init__(self, force_three_params=False, validator_function_name=&#34;validator&#34;):
        self.force_three_params = force_three_params
        self.validator_function_name = validator_function_name

    def visit_sequence(
        self, node_seq: typing.List[typedstmt]
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        def g(s: plt.AST):
            for n in reversed(node_seq):
                compiled_stmt = self.visit(n)
                s = compiled_stmt(s)
            return s

        return g

    def visit_BinOp(self, node: TypedBinOp) -&gt; plt.AST:
        opmap = BinOpMap.get(type(node.op))
        if opmap is None:
            raise NotImplementedError(f&#34;Operation {node.op} is not implemented&#34;)
        opmap2 = opmap.get(node.left.typ)
        if opmap2 is None:
            raise NotImplementedError(
                f&#34;Operation {node.op} is not implemented for left type {node.left.typ}&#34;
            )
        op = opmap2.get(node.right.typ)
        if opmap2 is None:
            raise NotImplementedError(
                f&#34;Operation {node.op} is not implemented for left type {node.left.typ} and right type {node.right.typ}&#34;
            )
        return op(self.visit(node.left), self.visit(node.right))

    def visit_BoolOp(self, node: TypedBoolOp) -&gt; plt.AST:
        op = BoolOpMap.get(type(node.op))
        assert len(node.values) &gt;= 2, &#34;Need to compare at least to values&#34;
        ops = op(
            self.visit(node.values[0]),
            self.visit(node.values[1]),
        )
        for v in node.values[2:]:
            ops = op(ops, self.visit(v))
        return ops

    def visit_UnaryOp(self, node: TypedUnaryOp) -&gt; plt.AST:
        opmap = UnaryOpMap.get(type(node.op))
        assert opmap is not None, f&#34;Operator {type(node.op)} is not supported&#34;
        op = opmap.get(node.operand.typ)
        assert (
            op is not None
        ), f&#34;Operator {type(node.op)} is not supported for type {node.operand.typ}&#34;
        return op(self.visit(node.operand))

    def visit_Compare(self, node: TypedCompare) -&gt; plt.AST:
        assert len(node.ops) == 1, &#34;Only single comparisons are supported&#34;
        assert len(node.comparators) == 1, &#34;Only single comparisons are supported&#34;
        cmpop = node.ops[0]
        comparator = node.comparators[0].typ
        op = node.left.typ.cmp(cmpop, comparator)
        return plt.Apply(
            op,
            self.visit(node.left),
            self.visit(node.comparators[0]),
        )

    def visit_Module(self, node: TypedModule) -&gt; plt.AST:
        # find main function
        # TODO can use more sophisiticated procedure here i.e. functions marked by comment
        main_fun: typing.Optional[InstanceType] = None
        for s in node.body:
            if isinstance(s, FunctionDef) and s.name == self.validator_function_name:
                main_fun = s
        assert (
            main_fun is not None
        ), f&#34;Could not find function named {self.validator_function_name}&#34;
        main_fun_typ: FunctionType = main_fun.typ.typ
        assert isinstance(
            main_fun_typ, FunctionType
        ), f&#34;Variable named {self.validator_function_name} is not of type function&#34;

        # check if this is a contract written to double function
        enable_double_func_mint_spend = False
        if len(main_fun_typ.argtyps) &gt;= 3 and self.force_three_params:
            # check if is possible
            second_last_arg = main_fun_typ.argtyps[-2]
            assert isinstance(
                second_last_arg, InstanceType
            ), &#34;Can not pass Class into validator&#34;
            if isinstance(second_last_arg.typ, UnionType):
                possible_types = second_last_arg.typ.typs
            else:
                possible_types = [second_last_arg.typ]
            if any(isinstance(t, UnitType) for t in possible_types):
                _LOGGER.warning(
                    &#34;The redeemer is annotated to be &#39;None&#39;. This value is usually encoded in PlutusData with constructor id 0 and no fields. If you want the script to double function as minting and spending script, annotate the second argument with &#39;NoRedeemer&#39;.&#34;
                )
            enable_double_func_mint_spend = not any(
                (isinstance(t, RecordType) and t.record.constructor == 0)
                or isinstance(t, UnitType)
                for t in possible_types
            )
            if not enable_double_func_mint_spend:
                _LOGGER.warning(
                    &#34;The second argument to the validator function potentially has constructor id 0. The validator will not be able to double function as minting script and spending script.&#34;
                )

        body = node.body + [
            TypedReturn(
                value=Name(
                    id=self.validator_function_name,
                    typ=InstanceType(main_fun_typ),
                    ctx=Load(),
                ),
                typ=InstanceType(main_fun_typ),
            )
        ]

        validator = plt.Lambda(
            [f&#34;p{i}&#34; for i, _ in enumerate(main_fun_typ.argtyps)],
            transform_output_map(main_fun_typ.rettyp)(
                plt.Let(
                    [
                        (
                            &#34;val&#34;,
                            self.visit_sequence(body)(
                                plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                            ),
                        ),
                    ],
                    plt.Apply(
                        plt.Var(&#34;val&#34;),
                        plt.Var(&#34;val&#34;),
                        *[
                            transform_ext_params_map(a)(plt.Var(f&#34;p{i}&#34;))
                            for i, a in enumerate(main_fun_typ.argtyps)
                        ],
                    ),
                ),
            ),
        )
        if enable_double_func_mint_spend:
            validator = wrap_validator_double_function(
                validator, pass_through=len(main_fun_typ.argtyps) - 3
            )
        elif self.force_three_params:
            # Error if the double function is enforced but not possible
            raise RuntimeError(
                &#34;The contract can not always detect if it was passed three or two parameters on-chain.&#34;
            )
        cp = plt.Program((1, 0, 0), validator)
        return cp

    def visit_Constant(self, node: TypedConstant) -&gt; plt.AST:
        plt_type = ConstantMap.get(type(node.value))
        if plt_type is None:
            raise NotImplementedError(
                f&#34;Constants of type {type(node.value)} are not supported&#34;
            )
        return plt_type(node.value)

    def visit_NoneType(self, _: typing.Optional[typing.Any]) -&gt; plt.AST:
        return plt.Unit()

    def visit_Assign(self, node: TypedAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
        assert (
            len(node.targets) == 1
        ), &#34;Assignments to more than one variable not supported yet&#34;
        assert isinstance(
            node.targets[0], Name
        ), &#34;Assignments to other things then names are not supported&#34;
        compiled_e = self.visit(node.value)
        varname = node.targets[0].id
        return lambda x: plt.Let([(varname, compiled_e)], x)

    def visit_AnnAssign(self, node: AnnAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
        assert isinstance(
            node.target, Name
        ), &#34;Assignments to other things than names are not supported&#34;
        assert isinstance(
            node.target.typ, InstanceType
        ), &#34;Can only assign instances to instances&#34;
        compiled_e = self.visit(node.value)
        # (\{STATEMONAD} -&gt; (\x -&gt; if (x ==b {self.visit(node.targets[0])}) then ({compiled_e} {STATEMONAD}) else ({STATEMONAD} x)))
        val = compiled_e
        if isinstance(node.value.typ, InstanceType) and isinstance(
            node.value.typ.typ, AnyType
        ):
            # we need to map this as it will originate from PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to builtin values
            val = transform_ext_params_map(node.target.typ)(val)
        if isinstance(node.target.typ, InstanceType) and isinstance(
            node.target.typ.typ, AnyType
        ):
            # we need to map this back as it will be treated as PlutusData
            # AnyType is the only type other than the builtin itself that can be cast to from builtin values
            val = transform_output_map(node.value.typ)(val)
        return lambda x: plt.Let([(node.target.id, val)], x)

    def visit_Name(self, node: TypedName) -&gt; plt.AST:
        # depending on load or store context, return the value of the variable or its name
        if not isinstance(node.ctx, Load):
            raise NotImplementedError(f&#34;Context {node.ctx} not supported&#34;)
        if isinstance(node.typ, ClassType):
            # if this is not an instance but a class, call the constructor
            return node.typ.constr()
        return plt.Var(node.id)

    def visit_Expr(self, node: TypedExpr) -&gt; typing.Callable[[plt.AST], plt.AST]:
        # we exploit UPLCs eager evaluation here
        # the expression is computed even though its value is eventually discarded
        # Note this really only makes sense for Trace
        # we use an invalid name here to avoid conflicts
        return lambda x: plt.Apply(plt.Lambda([&#34;0&#34;], x), self.visit(node.value))

    def visit_Call(self, node: TypedCall) -&gt; plt.AST:
        # compiled_args = &#34; &#34;.join(f&#34;({self.visit(a)} {STATEMONAD})&#34; for a in node.args)
        # return rf&#34;(\{STATEMONAD} -&gt; ({self.visit(node.func)} {compiled_args})&#34;
        # TODO function is actually not of type polymorphic function type here anymore
        if isinstance(node.func.typ, PolymorphicFunctionInstanceType):
            # edge case for weird builtins that are polymorphic
            func_plt = node.func.typ.polymorphic_function.impl_from_args(
                node.func.typ.typ.argtyps
            )
        else:
            func_plt = self.visit(node.func)
        args = []
        for a, t in zip(node.args, node.func.typ.typ.argtyps):
            assert isinstance(t, InstanceType)
            # pass in all arguments evaluated with the statemonad
            a_int = self.visit(a)
            if isinstance(t.typ, AnyType):
                # if the function expects input of generic type data, wrap data before passing it inside
                a_int = transform_output_map(a.typ)(a_int)
            args.append(a_int)
        return plt.Apply(
            plt.RecFun(func_plt),
            *args,
        )

    def visit_FunctionDef(
        self, node: TypedFunctionDef
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        body = node.body.copy()
        # defaults to returning None if there is no return statement
        if node.typ.typ.rettyp.typ == AnyType():
            ret_val = plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
        else:
            ret_val = plt.Unit()
        compiled_body = self.visit_sequence(body)(ret_val)
        return lambda x: plt.Let(
            [
                (
                    node.name,
                    plt.Lambda(
                        [node.name] + [a.arg for a in node.args.args],
                        compiled_body,
                    ),
                )
            ],
            x,
        )

    def visit_If(self, node: TypedIf) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Ite(
            self.visit(node.test),
            self.visit_sequence(node.body)(x),
            self.visit_sequence(node.orelse)(x),
        )

    def visit_Return(self, node: TypedReturn) -&gt; typing.Callable[[plt.AST], plt.AST]:
        # Throw away the term we were passed, this is going to be the last!
        compiled_return = self.visit(node.value)
        if isinstance(node.typ.typ, AnyType):
            # if the function returns generic data, wrap the function return value
            compiled_return = transform_output_map(node.value.typ)(compiled_return)
        return lambda _: compiled_return

    def visit_Pass(self, node: TypedPass) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: x

    def visit_Subscript(self, node: TypedSubscript) -&gt; plt.AST:
        assert isinstance(
            node.value.typ, InstanceType
        ), &#34;Can only access elements of instances, not classes&#34;
        if isinstance(node.value.typ.typ, TupleType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for tuples is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for tuples is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += len(node.value.typ.typ.typs)
            assert isinstance(node.ctx, Load), &#34;Tuples are read-only&#34;
            return plt.FunctionalTupleAccess(
                self.visit(node.value),
                index,
                len(node.value.typ.typ.typs),
            )
        if isinstance(node.value.typ.typ, PairType):
            assert isinstance(
                node.slice, Constant
            ), &#34;Only constant index access for pairs is supported&#34;
            assert isinstance(
                node.slice.value, int
            ), &#34;Only constant index integer access for pairs is supported&#34;
            index = node.slice.value
            if index &lt; 0:
                index += 2
            assert isinstance(node.ctx, Load), &#34;Pairs are read-only&#34;
            assert (
                0 &lt;= index &lt; 2
            ), f&#34;Pairs only have 2 elements, index should be 0 or 1, is {node.slice.value}&#34;
            member_func = plt.FstPair if index == 0 else plt.SndPair
            # the content of pairs is always Data, so we need to unwrap
            member_typ = node.typ
            return transform_ext_params_map(member_typ)(
                member_func(
                    self.visit(node.value),
                ),
            )
        if isinstance(node.value.typ.typ, ListType):
            assert (
                node.slice.typ == IntegerInstanceType
            ), &#34;Only single element list index access supported&#34;
            return plt.Let(
                [
                    (&#34;l&#34;, self.visit(node.value)),
                    (
                        &#34;raw_i&#34;,
                        self.visit(node.slice),
                    ),
                    (
                        &#34;i&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                            plt.AddInteger(
                                plt.Var(&#34;raw_i&#34;), plt.LengthList(plt.Var(&#34;l&#34;))
                            ),
                            plt.Var(&#34;raw_i&#34;),
                        ),
                    ),
                ],
                plt.IndexAccessList(plt.Var(&#34;l&#34;), plt.Var(&#34;i&#34;)),
            )
        elif isinstance(node.value.typ.typ, DictType):
            dict_typ = node.value.typ.typ
            if not isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;key&#34;,
                            self.visit(node.slice),
                        )
                    ],
                    transform_ext_params_map(dict_typ.value_typ)(
                        plt.SndPair(
                            plt.FindList(
                                self.visit(node.value),
                                plt.Lambda(
                                    [&#34;x&#34;],
                                    plt.EqualsData(
                                        transform_output_map(dict_typ.key_typ)(
                                            plt.Var(&#34;key&#34;)
                                        ),
                                        plt.FstPair(plt.Var(&#34;x&#34;)),
                                    ),
                                ),
                                plt.TraceError(&#34;KeyError&#34;),
                            ),
                        ),
                    ),
                )
        elif isinstance(node.value.typ.typ, ByteStringType):
            if not isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_ix&#34;,
                            self.visit(node.slice),
                        ),
                        (
                            &#34;ix&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_ix&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_ix&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_ix&#34;),
                            ),
                        ),
                    ],
                    plt.IndexByteString(plt.Var(&#34;bs&#34;), plt.Var(&#34;ix&#34;)),
                )
            elif isinstance(node.slice, Slice):
                return plt.Let(
                    [
                        (
                            &#34;bs&#34;,
                            self.visit(node.value),
                        ),
                        (
                            &#34;raw_i&#34;,
                            self.visit(node.slice.lower),
                        ),
                        (
                            &#34;i&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_i&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_i&#34;),
                            ),
                        ),
                        (
                            &#34;raw_j&#34;,
                            self.visit(node.slice.upper),
                        ),
                        (
                            &#34;j&#34;,
                            plt.Ite(
                                plt.LessThanInteger(plt.Var(&#34;raw_j&#34;), plt.Integer(0)),
                                plt.AddInteger(
                                    plt.Var(&#34;raw_j&#34;),
                                    plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                                ),
                                plt.Var(&#34;raw_j&#34;),
                            ),
                        ),
                        (
                            &#34;drop&#34;,
                            plt.Ite(
                                plt.LessThanEqualsInteger(plt.Var(&#34;i&#34;), plt.Integer(0)),
                                plt.Integer(0),
                                plt.Var(&#34;i&#34;),
                            ),
                        ),
                        (
                            &#34;take&#34;,
                            plt.SubtractInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;drop&#34;)),
                        ),
                    ],
                    plt.Ite(
                        plt.LessThanEqualsInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;i&#34;)),
                        plt.ByteString(b&#34;&#34;),
                        plt.SliceByteString(
                            plt.Var(&#34;drop&#34;),
                            plt.Var(&#34;take&#34;),
                            plt.Var(&#34;bs&#34;),
                        ),
                    ),
                )
        raise NotImplementedError(
            f&#39;Could not implement subscript &#34;{node.slice}&#34; of &#34;{node.value}&#34;&#39;
        )

    def visit_Tuple(self, node: TypedTuple) -&gt; plt.AST:
        return plt.FunctionalTuple(*(self.visit(e) for e in node.elts))

    def visit_ClassDef(
        self, node: TypedClassDef
    ) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Let([(node.name, node.class_typ.constr())], x)

    def visit_Attribute(self, node: TypedAttribute) -&gt; plt.AST:
        assert isinstance(
            node.typ, InstanceType
        ), &#34;Can only access attributes of instances&#34;
        obj = self.visit(node.value)
        attr = node.value.typ.attribute(node.attr)
        return plt.Apply(attr, obj)

    def visit_Assert(self, node: TypedAssert) -&gt; typing.Callable[[plt.AST], plt.AST]:
        return lambda x: plt.Ite(
            self.visit(node.test),
            x,
            plt.Apply(
                plt.Error(),
                plt.Trace(self.visit(node.msg), plt.Unit())
                if node.msg is not None
                else plt.Unit(),
            ),
        )

    def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; plt.AST:
        return node.expr

    def visit_List(self, node: TypedList) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, ListType)
        l = empty_list(node.typ.typ.typ)
        for e in reversed(node.elts):
            l = plt.MkCons(self.visit(e), l)
        return l

    def visit_Dict(self, node: TypedDict) -&gt; plt.AST:
        assert isinstance(node.typ, InstanceType)
        assert isinstance(node.typ.typ, DictType)
        key_type = node.typ.typ.key_typ
        value_type = node.typ.typ.value_typ
        l = plt.EmptyDataPairList()
        for k, v in zip(node.keys, node.values):
            l = plt.MkCons(
                plt.MkPairData(
                    transform_output_map(key_type)(self.visit(k)),
                    transform_output_map(value_type)(self.visit(v)),
                ),
                l,
            )
        return l

    def visit_IfExp(self, node: TypedIfExp) -&gt; plt.AST:
        return plt.Ite(
            self.visit(node.test),
            self.visit(node.body),
            self.visit(node.orelse),
        )

    def visit_ListComp(self, node: TypedListComp) -&gt; plt.AST:
        assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
        gen = node.generators[0]
        assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
        assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
        assert isinstance(
            gen.target, Name
        ), &#34;Can only assign value to singleton element&#34;
        lst = self.visit(gen.iter)
        ifs = None
        for ifexpr in gen.ifs:
            if ifs is None:
                ifs = self.visit(ifexpr)
            else:
                ifs = plt.And(ifs, self.visit(ifexpr))
        map_fun = plt.Lambda(
            [gen.target.id],
            self.visit(node.elt),
        )
        empty_list_con = empty_list(node.elt.typ)
        if ifs is not None:
            filter_fun = plt.Lambda(
                [gen.target.id],
                ifs,
            )
            return plt.MapFilterList(
                lst,
                filter_fun,
                map_fun,
                empty_list_con,
            )
        else:
            return plt.MapList(
                lst,
                map_fun,
                empty_list_con,
            )

    def generic_visit(self, node: AST) -&gt; plt.AST:
        raise NotImplementedError(f&#34;Can not compile {node}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeTransformer" href="util.html#hebi.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
<li><a title="hebi.typed_ast.TypedNodeTransformer" href="typed_ast.html#hebi.typed_ast.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.compiler.UPLCCompiler.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.compiler.UPLCCompiler.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node: _ast.AST) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node: AST) -&gt; plt.AST:
    raise NotImplementedError(f&#34;Can not compile {node}&#34;)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="hebi.util.CompilingNodeTransformer" href="util.html#hebi.util.CompilingNodeTransformer">CompilingNodeTransformer</a></code>.<code><a title="hebi.util.CompilingNodeTransformer.visit" href="util.html#hebi.util.CompilingNodeTransformer.visit">visit</a></code>
</p>
<div class="desc inherited"><p>Visit a node.</p></div>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node: _ast.AnnAssign) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_AnnAssign(self, node: AnnAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
    assert isinstance(
        node.target, Name
    ), &#34;Assignments to other things than names are not supported&#34;
    assert isinstance(
        node.target.typ, InstanceType
    ), &#34;Can only assign instances to instances&#34;
    compiled_e = self.visit(node.value)
    # (\{STATEMONAD} -&gt; (\x -&gt; if (x ==b {self.visit(node.targets[0])}) then ({compiled_e} {STATEMONAD}) else ({STATEMONAD} x)))
    val = compiled_e
    if isinstance(node.value.typ, InstanceType) and isinstance(
        node.value.typ.typ, AnyType
    ):
        # we need to map this as it will originate from PlutusData
        # AnyType is the only type other than the builtin itself that can be cast to builtin values
        val = transform_ext_params_map(node.target.typ)(val)
    if isinstance(node.target.typ, InstanceType) and isinstance(
        node.target.typ.typ, AnyType
    ):
        # we need to map this back as it will be treated as PlutusData
        # AnyType is the only type other than the builtin itself that can be cast to from builtin values
        val = transform_output_map(node.value.typ)(val)
    return lambda x: plt.Let([(node.target.id, val)], x)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Assert"><code class="name flex">
<span>def <span class="ident">visit_Assert</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedAssert" href="typed_ast.html#hebi.typed_ast.TypedAssert">TypedAssert</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assert(self, node: TypedAssert) -&gt; typing.Callable[[plt.AST], plt.AST]:
    return lambda x: plt.Ite(
        self.visit(node.test),
        x,
        plt.Apply(
            plt.Error(),
            plt.Trace(self.visit(node.msg), plt.Unit())
            if node.msg is not None
            else plt.Unit(),
        ),
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedAssign" href="typed_ast.html#hebi.typed_ast.TypedAssign">TypedAssign</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assign(self, node: TypedAssign) -&gt; typing.Callable[[plt.AST], plt.AST]:
    assert (
        len(node.targets) == 1
    ), &#34;Assignments to more than one variable not supported yet&#34;
    assert isinstance(
        node.targets[0], Name
    ), &#34;Assignments to other things then names are not supported&#34;
    compiled_e = self.visit(node.value)
    varname = node.targets[0].id
    return lambda x: plt.Let([(varname, compiled_e)], x)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedAttribute" href="typed_ast.html#hebi.typed_ast.TypedAttribute">TypedAttribute</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Attribute(self, node: TypedAttribute) -&gt; plt.AST:
    assert isinstance(
        node.typ, InstanceType
    ), &#34;Can only access attributes of instances&#34;
    obj = self.visit(node.value)
    attr = node.value.typ.attribute(node.attr)
    return plt.Apply(attr, obj)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedBinOp" href="typed_ast.html#hebi.typed_ast.TypedBinOp">TypedBinOp</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node: TypedBinOp) -&gt; plt.AST:
    opmap = BinOpMap.get(type(node.op))
    if opmap is None:
        raise NotImplementedError(f&#34;Operation {node.op} is not implemented&#34;)
    opmap2 = opmap.get(node.left.typ)
    if opmap2 is None:
        raise NotImplementedError(
            f&#34;Operation {node.op} is not implemented for left type {node.left.typ}&#34;
        )
    op = opmap2.get(node.right.typ)
    if opmap2 is None:
        raise NotImplementedError(
            f&#34;Operation {node.op} is not implemented for left type {node.left.typ} and right type {node.right.typ}&#34;
        )
    return op(self.visit(node.left), self.visit(node.right))</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_BoolOp"><code class="name flex">
<span>def <span class="ident">visit_BoolOp</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedBoolOp" href="typed_ast.html#hebi.typed_ast.TypedBoolOp">TypedBoolOp</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BoolOp(self, node: TypedBoolOp) -&gt; plt.AST:
    op = BoolOpMap.get(type(node.op))
    assert len(node.values) &gt;= 2, &#34;Need to compare at least to values&#34;
    ops = op(
        self.visit(node.values[0]),
        self.visit(node.values[1]),
    )
    for v in node.values[2:]:
        ops = op(ops, self.visit(v))
    return ops</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedCall" href="typed_ast.html#hebi.typed_ast.TypedCall">TypedCall</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node: TypedCall) -&gt; plt.AST:
    # compiled_args = &#34; &#34;.join(f&#34;({self.visit(a)} {STATEMONAD})&#34; for a in node.args)
    # return rf&#34;(\{STATEMONAD} -&gt; ({self.visit(node.func)} {compiled_args})&#34;
    # TODO function is actually not of type polymorphic function type here anymore
    if isinstance(node.func.typ, PolymorphicFunctionInstanceType):
        # edge case for weird builtins that are polymorphic
        func_plt = node.func.typ.polymorphic_function.impl_from_args(
            node.func.typ.typ.argtyps
        )
    else:
        func_plt = self.visit(node.func)
    args = []
    for a, t in zip(node.args, node.func.typ.typ.argtyps):
        assert isinstance(t, InstanceType)
        # pass in all arguments evaluated with the statemonad
        a_int = self.visit(a)
        if isinstance(t.typ, AnyType):
            # if the function expects input of generic type data, wrap data before passing it inside
            a_int = transform_output_map(a.typ)(a_int)
        args.append(a_int)
    return plt.Apply(
        plt.RecFun(func_plt),
        *args,
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedClassDef" href="typed_ast.html#hebi.typed_ast.TypedClassDef">TypedClassDef</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(
    self, node: TypedClassDef
) -&gt; typing.Callable[[plt.AST], plt.AST]:
    return lambda x: plt.Let([(node.name, node.class_typ.constr())], x)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Compare"><code class="name flex">
<span>def <span class="ident">visit_Compare</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedCompare" href="typed_ast.html#hebi.typed_ast.TypedCompare">TypedCompare</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Compare(self, node: TypedCompare) -&gt; plt.AST:
    assert len(node.ops) == 1, &#34;Only single comparisons are supported&#34;
    assert len(node.comparators) == 1, &#34;Only single comparisons are supported&#34;
    cmpop = node.ops[0]
    comparator = node.comparators[0].typ
    op = node.left.typ.cmp(cmpop, comparator)
    return plt.Apply(
        op,
        self.visit(node.left),
        self.visit(node.comparators[0]),
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedConstant" href="typed_ast.html#hebi.typed_ast.TypedConstant">TypedConstant</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node: TypedConstant) -&gt; plt.AST:
    plt_type = ConstantMap.get(type(node.value))
    if plt_type is None:
        raise NotImplementedError(
            f&#34;Constants of type {type(node.value)} are not supported&#34;
        )
    return plt_type(node.value)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Dict"><code class="name flex">
<span>def <span class="ident">visit_Dict</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedDict" href="typed_ast.html#hebi.typed_ast.TypedDict">TypedDict</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Dict(self, node: TypedDict) -&gt; plt.AST:
    assert isinstance(node.typ, InstanceType)
    assert isinstance(node.typ.typ, DictType)
    key_type = node.typ.typ.key_typ
    value_type = node.typ.typ.value_typ
    l = plt.EmptyDataPairList()
    for k, v in zip(node.keys, node.values):
        l = plt.MkCons(
            plt.MkPairData(
                transform_output_map(key_type)(self.visit(k)),
                transform_output_map(value_type)(self.visit(v)),
            ),
            l,
        )
    return l</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Expr"><code class="name flex">
<span>def <span class="ident">visit_Expr</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedExpr" href="typed_ast.html#hebi.typed_ast.TypedExpr">TypedExpr</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Expr(self, node: TypedExpr) -&gt; typing.Callable[[plt.AST], plt.AST]:
    # we exploit UPLCs eager evaluation here
    # the expression is computed even though its value is eventually discarded
    # Note this really only makes sense for Trace
    # we use an invalid name here to avoid conflicts
    return lambda x: plt.Apply(plt.Lambda([&#34;0&#34;], x), self.visit(node.value))</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedFunctionDef" href="typed_ast.html#hebi.typed_ast.TypedFunctionDef">TypedFunctionDef</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(
    self, node: TypedFunctionDef
) -&gt; typing.Callable[[plt.AST], plt.AST]:
    body = node.body.copy()
    # defaults to returning None if there is no return statement
    if node.typ.typ.rettyp.typ == AnyType():
        ret_val = plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
    else:
        ret_val = plt.Unit()
    compiled_body = self.visit_sequence(body)(ret_val)
    return lambda x: plt.Let(
        [
            (
                node.name,
                plt.Lambda(
                    [node.name] + [a.arg for a in node.args.args],
                    compiled_body,
                ),
            )
        ],
        x,
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedIf" href="typed_ast.html#hebi.typed_ast.TypedIf">TypedIf</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_If(self, node: TypedIf) -&gt; typing.Callable[[plt.AST], plt.AST]:
    return lambda x: plt.Ite(
        self.visit(node.test),
        self.visit_sequence(node.body)(x),
        self.visit_sequence(node.orelse)(x),
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_IfExp"><code class="name flex">
<span>def <span class="ident">visit_IfExp</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedIfExp" href="typed_ast.html#hebi.typed_ast.TypedIfExp">TypedIfExp</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_IfExp(self, node: TypedIfExp) -&gt; plt.AST:
    return plt.Ite(
        self.visit(node.test),
        self.visit(node.body),
        self.visit(node.orelse),
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedList" href="typed_ast.html#hebi.typed_ast.TypedList">TypedList</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_List(self, node: TypedList) -&gt; plt.AST:
    assert isinstance(node.typ, InstanceType)
    assert isinstance(node.typ.typ, ListType)
    l = empty_list(node.typ.typ.typ)
    for e in reversed(node.elts):
        l = plt.MkCons(self.visit(e), l)
    return l</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_ListComp"><code class="name flex">
<span>def <span class="ident">visit_ListComp</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedListComp" href="typed_ast.html#hebi.typed_ast.TypedListComp">TypedListComp</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ListComp(self, node: TypedListComp) -&gt; plt.AST:
    assert len(node.generators) == 1, &#34;Currently only one generator supported&#34;
    gen = node.generators[0]
    assert isinstance(gen.iter.typ, InstanceType), &#34;Only lists are valid generators&#34;
    assert isinstance(gen.iter.typ.typ, ListType), &#34;Only lists are valid generators&#34;
    assert isinstance(
        gen.target, Name
    ), &#34;Can only assign value to singleton element&#34;
    lst = self.visit(gen.iter)
    ifs = None
    for ifexpr in gen.ifs:
        if ifs is None:
            ifs = self.visit(ifexpr)
        else:
            ifs = plt.And(ifs, self.visit(ifexpr))
    map_fun = plt.Lambda(
        [gen.target.id],
        self.visit(node.elt),
    )
    empty_list_con = empty_list(node.elt.typ)
    if ifs is not None:
        filter_fun = plt.Lambda(
            [gen.target.id],
            ifs,
        )
        return plt.MapFilterList(
            lst,
            filter_fun,
            map_fun,
            empty_list_con,
        )
    else:
        return plt.MapList(
            lst,
            map_fun,
            empty_list_con,
        )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedModule" href="typed_ast.html#hebi.typed_ast.TypedModule">TypedModule</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Module(self, node: TypedModule) -&gt; plt.AST:
    # find main function
    # TODO can use more sophisiticated procedure here i.e. functions marked by comment
    main_fun: typing.Optional[InstanceType] = None
    for s in node.body:
        if isinstance(s, FunctionDef) and s.name == self.validator_function_name:
            main_fun = s
    assert (
        main_fun is not None
    ), f&#34;Could not find function named {self.validator_function_name}&#34;
    main_fun_typ: FunctionType = main_fun.typ.typ
    assert isinstance(
        main_fun_typ, FunctionType
    ), f&#34;Variable named {self.validator_function_name} is not of type function&#34;

    # check if this is a contract written to double function
    enable_double_func_mint_spend = False
    if len(main_fun_typ.argtyps) &gt;= 3 and self.force_three_params:
        # check if is possible
        second_last_arg = main_fun_typ.argtyps[-2]
        assert isinstance(
            second_last_arg, InstanceType
        ), &#34;Can not pass Class into validator&#34;
        if isinstance(second_last_arg.typ, UnionType):
            possible_types = second_last_arg.typ.typs
        else:
            possible_types = [second_last_arg.typ]
        if any(isinstance(t, UnitType) for t in possible_types):
            _LOGGER.warning(
                &#34;The redeemer is annotated to be &#39;None&#39;. This value is usually encoded in PlutusData with constructor id 0 and no fields. If you want the script to double function as minting and spending script, annotate the second argument with &#39;NoRedeemer&#39;.&#34;
            )
        enable_double_func_mint_spend = not any(
            (isinstance(t, RecordType) and t.record.constructor == 0)
            or isinstance(t, UnitType)
            for t in possible_types
        )
        if not enable_double_func_mint_spend:
            _LOGGER.warning(
                &#34;The second argument to the validator function potentially has constructor id 0. The validator will not be able to double function as minting script and spending script.&#34;
            )

    body = node.body + [
        TypedReturn(
            value=Name(
                id=self.validator_function_name,
                typ=InstanceType(main_fun_typ),
                ctx=Load(),
            ),
            typ=InstanceType(main_fun_typ),
        )
    ]

    validator = plt.Lambda(
        [f&#34;p{i}&#34; for i, _ in enumerate(main_fun_typ.argtyps)],
        transform_output_map(main_fun_typ.rettyp)(
            plt.Let(
                [
                    (
                        &#34;val&#34;,
                        self.visit_sequence(body)(
                            plt.ConstrData(plt.Integer(0), plt.EmptyDataList())
                        ),
                    ),
                ],
                plt.Apply(
                    plt.Var(&#34;val&#34;),
                    plt.Var(&#34;val&#34;),
                    *[
                        transform_ext_params_map(a)(plt.Var(f&#34;p{i}&#34;))
                        for i, a in enumerate(main_fun_typ.argtyps)
                    ],
                ),
            ),
        ),
    )
    if enable_double_func_mint_spend:
        validator = wrap_validator_double_function(
            validator, pass_through=len(main_fun_typ.argtyps) - 3
        )
    elif self.force_three_params:
        # Error if the double function is enforced but not possible
        raise RuntimeError(
            &#34;The contract can not always detect if it was passed three or two parameters on-chain.&#34;
        )
    cp = plt.Program((1, 0, 0), validator)
    return cp</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedName" href="typed_ast.html#hebi.typed_ast.TypedName">TypedName</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: TypedName) -&gt; plt.AST:
    # depending on load or store context, return the value of the variable or its name
    if not isinstance(node.ctx, Load):
        raise NotImplementedError(f&#34;Context {node.ctx} not supported&#34;)
    if isinstance(node.typ, ClassType):
        # if this is not an instance but a class, call the constructor
        return node.typ.constr()
    return plt.Var(node.id)</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_NoneType"><code class="name flex">
<span>def <span class="ident">visit_NoneType</span></span>(<span>self, _: Optional[Any]) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_NoneType(self, _: typing.Optional[typing.Any]) -&gt; plt.AST:
    return plt.Unit()</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Pass"><code class="name flex">
<span>def <span class="ident">visit_Pass</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedPass" href="typed_ast.html#hebi.typed_ast.TypedPass">TypedPass</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Pass(self, node: TypedPass) -&gt; typing.Callable[[plt.AST], plt.AST]:
    return lambda x: x</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_RawPlutoExpr"><code class="name flex">
<span>def <span class="ident">visit_RawPlutoExpr</span></span>(<span>self, node: <a title="hebi.typed_ast.RawPlutoExpr" href="typed_ast.html#hebi.typed_ast.RawPlutoExpr">RawPlutoExpr</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_RawPlutoExpr(self, node: RawPlutoExpr) -&gt; plt.AST:
    return node.expr</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Return"><code class="name flex">
<span>def <span class="ident">visit_Return</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedReturn" href="typed_ast.html#hebi.typed_ast.TypedReturn">TypedReturn</a>) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Return(self, node: TypedReturn) -&gt; typing.Callable[[plt.AST], plt.AST]:
    # Throw away the term we were passed, this is going to be the last!
    compiled_return = self.visit(node.value)
    if isinstance(node.typ.typ, AnyType):
        # if the function returns generic data, wrap the function return value
        compiled_return = transform_output_map(node.value.typ)(compiled_return)
    return lambda _: compiled_return</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedSubscript" href="typed_ast.html#hebi.typed_ast.TypedSubscript">TypedSubscript</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Subscript(self, node: TypedSubscript) -&gt; plt.AST:
    assert isinstance(
        node.value.typ, InstanceType
    ), &#34;Can only access elements of instances, not classes&#34;
    if isinstance(node.value.typ.typ, TupleType):
        assert isinstance(
            node.slice, Constant
        ), &#34;Only constant index access for tuples is supported&#34;
        assert isinstance(
            node.slice.value, int
        ), &#34;Only constant index integer access for tuples is supported&#34;
        index = node.slice.value
        if index &lt; 0:
            index += len(node.value.typ.typ.typs)
        assert isinstance(node.ctx, Load), &#34;Tuples are read-only&#34;
        return plt.FunctionalTupleAccess(
            self.visit(node.value),
            index,
            len(node.value.typ.typ.typs),
        )
    if isinstance(node.value.typ.typ, PairType):
        assert isinstance(
            node.slice, Constant
        ), &#34;Only constant index access for pairs is supported&#34;
        assert isinstance(
            node.slice.value, int
        ), &#34;Only constant index integer access for pairs is supported&#34;
        index = node.slice.value
        if index &lt; 0:
            index += 2
        assert isinstance(node.ctx, Load), &#34;Pairs are read-only&#34;
        assert (
            0 &lt;= index &lt; 2
        ), f&#34;Pairs only have 2 elements, index should be 0 or 1, is {node.slice.value}&#34;
        member_func = plt.FstPair if index == 0 else plt.SndPair
        # the content of pairs is always Data, so we need to unwrap
        member_typ = node.typ
        return transform_ext_params_map(member_typ)(
            member_func(
                self.visit(node.value),
            ),
        )
    if isinstance(node.value.typ.typ, ListType):
        assert (
            node.slice.typ == IntegerInstanceType
        ), &#34;Only single element list index access supported&#34;
        return plt.Let(
            [
                (&#34;l&#34;, self.visit(node.value)),
                (
                    &#34;raw_i&#34;,
                    self.visit(node.slice),
                ),
                (
                    &#34;i&#34;,
                    plt.Ite(
                        plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                        plt.AddInteger(
                            plt.Var(&#34;raw_i&#34;), plt.LengthList(plt.Var(&#34;l&#34;))
                        ),
                        plt.Var(&#34;raw_i&#34;),
                    ),
                ),
            ],
            plt.IndexAccessList(plt.Var(&#34;l&#34;), plt.Var(&#34;i&#34;)),
        )
    elif isinstance(node.value.typ.typ, DictType):
        dict_typ = node.value.typ.typ
        if not isinstance(node.slice, Slice):
            return plt.Let(
                [
                    (
                        &#34;key&#34;,
                        self.visit(node.slice),
                    )
                ],
                transform_ext_params_map(dict_typ.value_typ)(
                    plt.SndPair(
                        plt.FindList(
                            self.visit(node.value),
                            plt.Lambda(
                                [&#34;x&#34;],
                                plt.EqualsData(
                                    transform_output_map(dict_typ.key_typ)(
                                        plt.Var(&#34;key&#34;)
                                    ),
                                    plt.FstPair(plt.Var(&#34;x&#34;)),
                                ),
                            ),
                            plt.TraceError(&#34;KeyError&#34;),
                        ),
                    ),
                ),
            )
    elif isinstance(node.value.typ.typ, ByteStringType):
        if not isinstance(node.slice, Slice):
            return plt.Let(
                [
                    (
                        &#34;bs&#34;,
                        self.visit(node.value),
                    ),
                    (
                        &#34;raw_ix&#34;,
                        self.visit(node.slice),
                    ),
                    (
                        &#34;ix&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;raw_ix&#34;), plt.Integer(0)),
                            plt.AddInteger(
                                plt.Var(&#34;raw_ix&#34;),
                                plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                            ),
                            plt.Var(&#34;raw_ix&#34;),
                        ),
                    ),
                ],
                plt.IndexByteString(plt.Var(&#34;bs&#34;), plt.Var(&#34;ix&#34;)),
            )
        elif isinstance(node.slice, Slice):
            return plt.Let(
                [
                    (
                        &#34;bs&#34;,
                        self.visit(node.value),
                    ),
                    (
                        &#34;raw_i&#34;,
                        self.visit(node.slice.lower),
                    ),
                    (
                        &#34;i&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;raw_i&#34;), plt.Integer(0)),
                            plt.AddInteger(
                                plt.Var(&#34;raw_i&#34;),
                                plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                            ),
                            plt.Var(&#34;raw_i&#34;),
                        ),
                    ),
                    (
                        &#34;raw_j&#34;,
                        self.visit(node.slice.upper),
                    ),
                    (
                        &#34;j&#34;,
                        plt.Ite(
                            plt.LessThanInteger(plt.Var(&#34;raw_j&#34;), plt.Integer(0)),
                            plt.AddInteger(
                                plt.Var(&#34;raw_j&#34;),
                                plt.LengthOfByteString(plt.Var(&#34;bs&#34;)),
                            ),
                            plt.Var(&#34;raw_j&#34;),
                        ),
                    ),
                    (
                        &#34;drop&#34;,
                        plt.Ite(
                            plt.LessThanEqualsInteger(plt.Var(&#34;i&#34;), plt.Integer(0)),
                            plt.Integer(0),
                            plt.Var(&#34;i&#34;),
                        ),
                    ),
                    (
                        &#34;take&#34;,
                        plt.SubtractInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;drop&#34;)),
                    ),
                ],
                plt.Ite(
                    plt.LessThanEqualsInteger(plt.Var(&#34;j&#34;), plt.Var(&#34;i&#34;)),
                    plt.ByteString(b&#34;&#34;),
                    plt.SliceByteString(
                        plt.Var(&#34;drop&#34;),
                        plt.Var(&#34;take&#34;),
                        plt.Var(&#34;bs&#34;),
                    ),
                ),
            )
    raise NotImplementedError(
        f&#39;Could not implement subscript &#34;{node.slice}&#34; of &#34;{node.value}&#34;&#39;
    )</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedTuple" href="typed_ast.html#hebi.typed_ast.TypedTuple">TypedTuple</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Tuple(self, node: TypedTuple) -&gt; plt.AST:
    return plt.FunctionalTuple(*(self.visit(e) for e in node.elts))</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node: <a title="hebi.typed_ast.TypedUnaryOp" href="typed_ast.html#hebi.typed_ast.TypedUnaryOp">TypedUnaryOp</a>) ‑> pluthon.pluthon_ast.AST</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node: TypedUnaryOp) -&gt; plt.AST:
    opmap = UnaryOpMap.get(type(node.op))
    assert opmap is not None, f&#34;Operator {type(node.op)} is not supported&#34;
    op = opmap.get(node.operand.typ)
    assert (
        op is not None
    ), f&#34;Operator {type(node.op)} is not supported for type {node.operand.typ}&#34;
    return op(self.visit(node.operand))</code></pre>
</details>
</dd>
<dt id="hebi.compiler.UPLCCompiler.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self, node_seq: List[<a title="hebi.typed_ast.typedstmt" href="typed_ast.html#hebi.typed_ast.typedstmt">typedstmt</a>]) ‑> Callable[[pluthon.pluthon_ast.AST], pluthon.pluthon_ast.AST]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_sequence(
    self, node_seq: typing.List[typedstmt]
) -&gt; typing.Callable[[plt.AST], plt.AST]:
    def g(s: plt.AST):
        for n in reversed(node_seq):
            compiled_stmt = self.visit(n)
            s = compiled_stmt(s)
        return s

    return g</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div style="max-width: 330px; margin-bottom: 10px">
<header>
<a class="homelink" rel="home" title="hebi Home" href="https://hebi.opshin.dev/">
<img src="https://raw.githubusercontent.com/OpShin/hebi/master/hebi.png" alt="hebi logo"> &nbsp; hebi
</a>
</header>
</div>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hebi" href="index.html">hebi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="hebi.compiler.compile" href="#hebi.compiler.compile">compile</a></code></li>
<li><code><a title="hebi.compiler.wrap_validator_double_function" href="#hebi.compiler.wrap_validator_double_function">wrap_validator_double_function</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hebi.compiler.UPLCCompiler" href="#hebi.compiler.UPLCCompiler">UPLCCompiler</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.compiler.UPLCCompiler.generic_visit" href="#hebi.compiler.UPLCCompiler.generic_visit">generic_visit</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.step" href="#hebi.compiler.UPLCCompiler.step">step</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit" href="util.html#hebi.compiler.UPLCCompiler.visit">visit</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_AnnAssign" href="#hebi.compiler.UPLCCompiler.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Assert" href="#hebi.compiler.UPLCCompiler.visit_Assert">visit_Assert</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Assign" href="#hebi.compiler.UPLCCompiler.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Attribute" href="#hebi.compiler.UPLCCompiler.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_BinOp" href="#hebi.compiler.UPLCCompiler.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_BoolOp" href="#hebi.compiler.UPLCCompiler.visit_BoolOp">visit_BoolOp</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Call" href="#hebi.compiler.UPLCCompiler.visit_Call">visit_Call</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_ClassDef" href="#hebi.compiler.UPLCCompiler.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Compare" href="#hebi.compiler.UPLCCompiler.visit_Compare">visit_Compare</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Constant" href="#hebi.compiler.UPLCCompiler.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Dict" href="#hebi.compiler.UPLCCompiler.visit_Dict">visit_Dict</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Expr" href="#hebi.compiler.UPLCCompiler.visit_Expr">visit_Expr</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_FunctionDef" href="#hebi.compiler.UPLCCompiler.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_If" href="#hebi.compiler.UPLCCompiler.visit_If">visit_If</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_IfExp" href="#hebi.compiler.UPLCCompiler.visit_IfExp">visit_IfExp</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_List" href="#hebi.compiler.UPLCCompiler.visit_List">visit_List</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_ListComp" href="#hebi.compiler.UPLCCompiler.visit_ListComp">visit_ListComp</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Module" href="#hebi.compiler.UPLCCompiler.visit_Module">visit_Module</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Name" href="#hebi.compiler.UPLCCompiler.visit_Name">visit_Name</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_NoneType" href="#hebi.compiler.UPLCCompiler.visit_NoneType">visit_NoneType</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Pass" href="#hebi.compiler.UPLCCompiler.visit_Pass">visit_Pass</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_RawPlutoExpr" href="#hebi.compiler.UPLCCompiler.visit_RawPlutoExpr">visit_RawPlutoExpr</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Return" href="#hebi.compiler.UPLCCompiler.visit_Return">visit_Return</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Subscript" href="#hebi.compiler.UPLCCompiler.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_Tuple" href="#hebi.compiler.UPLCCompiler.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_UnaryOp" href="#hebi.compiler.UPLCCompiler.visit_UnaryOp">visit_UnaryOp</a></code></li>
<li><code><a title="hebi.compiler.UPLCCompiler.visit_sequence" href="#hebi.compiler.UPLCCompiler.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>