<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hebi.optimize.optimize_remove_deadvars API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hebi.optimize.optimize_remove_deadvars</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ast import *
from copy import copy
from collections import defaultdict

from ..util import CompilingNodeVisitor, CompilingNodeTransformer
from ..type_inference import INITIAL_SCOPE

&#34;&#34;&#34;
Removes assignments to variables that are never read
&#34;&#34;&#34;


class NameLoadCollector(CompilingNodeVisitor):
    step = &#34;Collecting used variables&#34;

    def __init__(self):
        self.loaded = defaultdict(int)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Load):
            self.loaded[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        for s in node.body:
            self.visit(s)


class SafeOperationVisitor(CompilingNodeVisitor):
    step = &#34;Collecting computations that can not throw errors&#34;

    def __init__(self, guaranteed_names):
        self.guaranteed_names = guaranteed_names

    def generic_visit(self, node: AST) -&gt; bool:
        # generally every operation is unsafe except we whitelist it
        return False

    def visit_Lambda(self, node: Lambda) -&gt; bool:
        # lambda definition is fine as it actually doesn&#39;t compute anything
        return True

    def visit_Constant(self, node: Constant) -&gt; bool:
        # Constants can not fail
        return True

    def visit_RawPlutoExpr(self, node) -&gt; bool:
        # these expressions are not evaluated further
        return True

    def visit_Name(self, node: Name) -&gt; bool:
        return node.id in self.guaranteed_names


class OptimizeRemoveDeadvars(CompilingNodeTransformer):
    step = &#34;Removing unused variables&#34;

    loaded_vars = None
    # names that are guaranteed to be available to the current node
    # this acts differently to the type inferencer! in particular, ite/while/for all produce their own scope
    guaranteed_avail_names = [list(INITIAL_SCOPE.keys())]

    def guaranteed(self, name: str) -&gt; bool:
        name = name
        for scope in reversed(self.guaranteed_avail_names):
            if name in scope:
                return True
        return False

    def enter_scope(self):
        self.guaranteed_avail_names.append([])

    def exit_scope(self):
        self.guaranteed_avail_names.pop()

    def set_guaranteed(self, name: str):
        self.guaranteed_avail_names[-1].append(name)

    def visit_Module(self, node: Module) -&gt; Module:
        # repeat until no more change due to removal
        # i.e. b = a; c = b needs 2 passes to remove c and b
        node_cp = copy(node)
        self.loaded_vars = None
        while True:
            self.enter_scope()
            # collect all variable names
            collector = NameLoadCollector()
            collector.visit(node_cp)
            loaded_vars = set(collector.loaded.keys()) | {&#34;validator&#34;}
            # break if the set of loaded vars did not change -&gt; set of vars to remove does also not change
            if loaded_vars == self.loaded_vars:
                break
            # remove unloaded ones
            self.loaded_vars = loaded_vars
            node_cp.body = [self.visit(s) for s in node_cp.body]
            self.exit_scope()
        return node_cp

    def visit_If(self, node: If):
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        self.enter_scope()
        node_cp.body = [self.visit(s) for s in node.body]
        scope_body_cp = self.guaranteed_avail_names[-1].copy()
        self.exit_scope()
        self.enter_scope()
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        scope_orelse_cp = self.guaranteed_avail_names[-1].copy()
        self.exit_scope()
        # what remains after this in the scope is the intersection of both
        for var in set(scope_body_cp).intersection(scope_orelse_cp):
            self.set_guaranteed(var)
        return node_cp

    def visit_While(self, node: While):
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        self.enter_scope()
        node_cp.body = [self.visit(s) for s in node.body]
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        self.exit_scope()
        return node_cp

    def visit_For(self, node: For):
        node_cp = copy(node)
        assert isinstance(node.target, Name), &#34;Can only assign to singleton name&#34;
        self.enter_scope()
        self.guaranteed(node.target.id)
        node_cp.body = [self.visit(s) for s in node.body]
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        self.exit_scope()
        return node_cp

    def visit_Assign(self, node: Assign):
        if (
            len(node.targets) != 1
            or not isinstance(node.targets[0], Name)
            or node.targets[0].id in self.loaded_vars
            or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
                node.value
            )
        ):
            for t in node.targets:
                assert isinstance(
                    t, Name
                ), &#34;Need to have name for dead var remover to work&#34;
                self.set_guaranteed(t.id)
            return self.generic_visit(node)
        return Pass()

    def visit_AnnAssign(self, node: AnnAssign):
        if (
            not isinstance(node.target, Name)
            or node.target.id in self.loaded_vars
            or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
                node.value
            )
        ):
            assert isinstance(
                node.target, Name
            ), &#34;Need to have assignments to name for dead var remover to work&#34;
            self.set_guaranteed(node.target.id)
            return self.generic_visit(node)
        return Pass()

    def visit_ClassDef(self, node: ClassDef):
        if node.name in self.loaded_vars:
            self.set_guaranteed(node.name)
            return node
        return Pass()

    def visit_FunctionDef(self, node: FunctionDef):
        node_cp = copy(node)
        if node.name in self.loaded_vars:
            self.set_guaranteed(node.name)
            self.enter_scope()
            # variable names are available here
            for a in node.args.args:
                self.set_guaranteed(a.arg)
            node_cp.body = [self.visit(s) for s in node.body]
            self.exit_scope()
            return node_cp
        return Pass()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.NameLoadCollector"><code class="flex name class">
<span>class <span class="ident">NameLoadCollector</span></span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NameLoadCollector(CompilingNodeVisitor):
    step = &#34;Collecting used variables&#34;

    def __init__(self):
        self.loaded = defaultdict(int)

    def visit_Name(self, node: Name) -&gt; None:
        if isinstance(node.ctx, Load):
            self.loaded[node.id] += 1

    def visit_ClassDef(self, node: ClassDef):
        # ignore the content (i.e. attribute names) of class definitions
        pass

    def visit_FunctionDef(self, node: FunctionDef):
        # ignore the type hints of function arguments
        for s in node.body:
            self.visit(s)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeVisitor" href="../util.html#hebi.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
<li><a title="hebi.typed_ast.TypedNodeVisitor" href="../typed_ast.html#hebi.typed_ast.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node: _ast.ClassDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef):
    # ignore the content (i.e. attribute names) of class definitions
    pass</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node: _ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(self, node: FunctionDef):
    # ignore the type hints of function arguments
    for s in node.body:
        self.visit(s)</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node: _ast.Name) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: Name) -&gt; None:
    if isinstance(node.ctx, Load):
        self.loaded[node.id] += 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hebi.util.CompilingNodeVisitor" href="../util.html#hebi.util.CompilingNodeVisitor">CompilingNodeVisitor</a></b></code>:
<ul class="hlist">
<li><code><a title="hebi.util.CompilingNodeVisitor.visit" href="../typed_ast.html#hebi.typed_ast.TypedNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars"><code class="flex name class">
<span>class <span class="ident">OptimizeRemoveDeadvars</span></span>
</code></dt>
<dd>
<div class="desc"><p>A :class:<code>NodeVisitor</code> subclass that walks the abstract syntax tree and
allows modification of nodes.</p>
<p>The <code>NodeTransformer</code> will walk the AST and use the return value of the
visitor methods to replace or remove the old node.
If the return value of
the visitor method is <code>None</code>, the node will be removed from its location,
otherwise it is replaced with the return value.
The return value may be the
original node in which case no replacement takes place.</p>
<p>Here is an example transformer that rewrites all occurrences of name lookups
(<code>foo</code>) to <code>data['foo']</code>::</p>
<p>class RewriteName(NodeTransformer):</p>
<pre><code>   def visit_Name(self, node):
       return Subscript(
           value=Name(id='data', ctx=Load()),
           slice=Index(value=Str(s=node.id)),
           ctx=node.ctx
       )
</code></pre>
<p>Keep in mind that if the node you're operating on has child nodes you must
either transform the child nodes yourself or call the :meth:<code>generic_visit</code>
method for the node first.</p>
<p>For nodes that were part of a collection of statements (that applies to all
statement nodes), the visitor may also return a list of nodes rather than
just a single node.</p>
<p>Usually you use the transformer like this::</p>
<p>node = YourTransformer().visit(node)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizeRemoveDeadvars(CompilingNodeTransformer):
    step = &#34;Removing unused variables&#34;

    loaded_vars = None
    # names that are guaranteed to be available to the current node
    # this acts differently to the type inferencer! in particular, ite/while/for all produce their own scope
    guaranteed_avail_names = [list(INITIAL_SCOPE.keys())]

    def guaranteed(self, name: str) -&gt; bool:
        name = name
        for scope in reversed(self.guaranteed_avail_names):
            if name in scope:
                return True
        return False

    def enter_scope(self):
        self.guaranteed_avail_names.append([])

    def exit_scope(self):
        self.guaranteed_avail_names.pop()

    def set_guaranteed(self, name: str):
        self.guaranteed_avail_names[-1].append(name)

    def visit_Module(self, node: Module) -&gt; Module:
        # repeat until no more change due to removal
        # i.e. b = a; c = b needs 2 passes to remove c and b
        node_cp = copy(node)
        self.loaded_vars = None
        while True:
            self.enter_scope()
            # collect all variable names
            collector = NameLoadCollector()
            collector.visit(node_cp)
            loaded_vars = set(collector.loaded.keys()) | {&#34;validator&#34;}
            # break if the set of loaded vars did not change -&gt; set of vars to remove does also not change
            if loaded_vars == self.loaded_vars:
                break
            # remove unloaded ones
            self.loaded_vars = loaded_vars
            node_cp.body = [self.visit(s) for s in node_cp.body]
            self.exit_scope()
        return node_cp

    def visit_If(self, node: If):
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        self.enter_scope()
        node_cp.body = [self.visit(s) for s in node.body]
        scope_body_cp = self.guaranteed_avail_names[-1].copy()
        self.exit_scope()
        self.enter_scope()
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        scope_orelse_cp = self.guaranteed_avail_names[-1].copy()
        self.exit_scope()
        # what remains after this in the scope is the intersection of both
        for var in set(scope_body_cp).intersection(scope_orelse_cp):
            self.set_guaranteed(var)
        return node_cp

    def visit_While(self, node: While):
        node_cp = copy(node)
        node_cp.test = self.visit(node.test)
        self.enter_scope()
        node_cp.body = [self.visit(s) for s in node.body]
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        self.exit_scope()
        return node_cp

    def visit_For(self, node: For):
        node_cp = copy(node)
        assert isinstance(node.target, Name), &#34;Can only assign to singleton name&#34;
        self.enter_scope()
        self.guaranteed(node.target.id)
        node_cp.body = [self.visit(s) for s in node.body]
        node_cp.orelse = [self.visit(s) for s in node.orelse]
        self.exit_scope()
        return node_cp

    def visit_Assign(self, node: Assign):
        if (
            len(node.targets) != 1
            or not isinstance(node.targets[0], Name)
            or node.targets[0].id in self.loaded_vars
            or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
                node.value
            )
        ):
            for t in node.targets:
                assert isinstance(
                    t, Name
                ), &#34;Need to have name for dead var remover to work&#34;
                self.set_guaranteed(t.id)
            return self.generic_visit(node)
        return Pass()

    def visit_AnnAssign(self, node: AnnAssign):
        if (
            not isinstance(node.target, Name)
            or node.target.id in self.loaded_vars
            or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
                node.value
            )
        ):
            assert isinstance(
                node.target, Name
            ), &#34;Need to have assignments to name for dead var remover to work&#34;
            self.set_guaranteed(node.target.id)
            return self.generic_visit(node)
        return Pass()

    def visit_ClassDef(self, node: ClassDef):
        if node.name in self.loaded_vars:
            self.set_guaranteed(node.name)
            return node
        return Pass()

    def visit_FunctionDef(self, node: FunctionDef):
        node_cp = copy(node)
        if node.name in self.loaded_vars:
            self.set_guaranteed(node.name)
            self.enter_scope()
            # variable names are available here
            for a in node.args.args:
                self.set_guaranteed(a.arg)
            node_cp.body = [self.visit(s) for s in node.body]
            self.exit_scope()
            return node_cp
        return Pass()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeTransformer" href="../util.html#hebi.util.CompilingNodeTransformer">CompilingNodeTransformer</a></li>
<li><a title="hebi.typed_ast.TypedNodeTransformer" href="../typed_ast.html#hebi.typed_ast.TypedNodeTransformer">TypedNodeTransformer</a></li>
<li>ast.NodeTransformer</li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed_avail_names"><code class="name">var <span class="ident">guaranteed_avail_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.loaded_vars"><code class="name">var <span class="ident">loaded_vars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.enter_scope"><code class="name flex">
<span>def <span class="ident">enter_scope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter_scope(self):
    self.guaranteed_avail_names.append([])</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.exit_scope"><code class="name flex">
<span>def <span class="ident">exit_scope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_scope(self):
    self.guaranteed_avail_names.pop()</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed"><code class="name flex">
<span>def <span class="ident">guaranteed</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def guaranteed(self, name: str) -&gt; bool:
    name = name
    for scope in reversed(self.guaranteed_avail_names):
        if name in scope:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.set_guaranteed"><code class="name flex">
<span>def <span class="ident">set_guaranteed</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_guaranteed(self, name: str):
    self.guaranteed_avail_names[-1].append(name)</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_AnnAssign"><code class="name flex">
<span>def <span class="ident">visit_AnnAssign</span></span>(<span>self, node: _ast.AnnAssign)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_AnnAssign(self, node: AnnAssign):
    if (
        not isinstance(node.target, Name)
        or node.target.id in self.loaded_vars
        or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
            node.value
        )
    ):
        assert isinstance(
            node.target, Name
        ), &#34;Need to have assignments to name for dead var remover to work&#34;
        self.set_guaranteed(node.target.id)
        return self.generic_visit(node)
    return Pass()</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Assign"><code class="name flex">
<span>def <span class="ident">visit_Assign</span></span>(<span>self, node: _ast.Assign)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Assign(self, node: Assign):
    if (
        len(node.targets) != 1
        or not isinstance(node.targets[0], Name)
        or node.targets[0].id in self.loaded_vars
        or not SafeOperationVisitor(sum(self.guaranteed_avail_names, [])).visit(
            node.value
        )
    ):
        for t in node.targets:
            assert isinstance(
                t, Name
            ), &#34;Need to have name for dead var remover to work&#34;
            self.set_guaranteed(t.id)
        return self.generic_visit(node)
    return Pass()</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_ClassDef"><code class="name flex">
<span>def <span class="ident">visit_ClassDef</span></span>(<span>self, node: _ast.ClassDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ClassDef(self, node: ClassDef):
    if node.name in self.loaded_vars:
        self.set_guaranteed(node.name)
        return node
    return Pass()</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_For"><code class="name flex">
<span>def <span class="ident">visit_For</span></span>(<span>self, node: _ast.For)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_For(self, node: For):
    node_cp = copy(node)
    assert isinstance(node.target, Name), &#34;Can only assign to singleton name&#34;
    self.enter_scope()
    self.guaranteed(node.target.id)
    node_cp.body = [self.visit(s) for s in node.body]
    node_cp.orelse = [self.visit(s) for s in node.orelse]
    self.exit_scope()
    return node_cp</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_FunctionDef"><code class="name flex">
<span>def <span class="ident">visit_FunctionDef</span></span>(<span>self, node: _ast.FunctionDef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_FunctionDef(self, node: FunctionDef):
    node_cp = copy(node)
    if node.name in self.loaded_vars:
        self.set_guaranteed(node.name)
        self.enter_scope()
        # variable names are available here
        for a in node.args.args:
            self.set_guaranteed(a.arg)
        node_cp.body = [self.visit(s) for s in node.body]
        self.exit_scope()
        return node_cp
    return Pass()</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_If"><code class="name flex">
<span>def <span class="ident">visit_If</span></span>(<span>self, node: _ast.If)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_If(self, node: If):
    node_cp = copy(node)
    node_cp.test = self.visit(node.test)
    self.enter_scope()
    node_cp.body = [self.visit(s) for s in node.body]
    scope_body_cp = self.guaranteed_avail_names[-1].copy()
    self.exit_scope()
    self.enter_scope()
    node_cp.orelse = [self.visit(s) for s in node.orelse]
    scope_orelse_cp = self.guaranteed_avail_names[-1].copy()
    self.exit_scope()
    # what remains after this in the scope is the intersection of both
    for var in set(scope_body_cp).intersection(scope_orelse_cp):
        self.set_guaranteed(var)
    return node_cp</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Module"><code class="name flex">
<span>def <span class="ident">visit_Module</span></span>(<span>self, node: _ast.Module) ‑> _ast.Module</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Module(self, node: Module) -&gt; Module:
    # repeat until no more change due to removal
    # i.e. b = a; c = b needs 2 passes to remove c and b
    node_cp = copy(node)
    self.loaded_vars = None
    while True:
        self.enter_scope()
        # collect all variable names
        collector = NameLoadCollector()
        collector.visit(node_cp)
        loaded_vars = set(collector.loaded.keys()) | {&#34;validator&#34;}
        # break if the set of loaded vars did not change -&gt; set of vars to remove does also not change
        if loaded_vars == self.loaded_vars:
            break
        # remove unloaded ones
        self.loaded_vars = loaded_vars
        node_cp.body = [self.visit(s) for s in node_cp.body]
        self.exit_scope()
    return node_cp</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_While"><code class="name flex">
<span>def <span class="ident">visit_While</span></span>(<span>self, node: _ast.While)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_While(self, node: While):
    node_cp = copy(node)
    node_cp.test = self.visit(node.test)
    self.enter_scope()
    node_cp.body = [self.visit(s) for s in node.body]
    node_cp.orelse = [self.visit(s) for s in node.orelse]
    self.exit_scope()
    return node_cp</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hebi.util.CompilingNodeTransformer" href="../util.html#hebi.util.CompilingNodeTransformer">CompilingNodeTransformer</a></b></code>:
<ul class="hlist">
<li><code><a title="hebi.util.CompilingNodeTransformer.visit" href="../typed_ast.html#hebi.typed_ast.TypedNodeTransformer.visit">visit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor"><code class="flex name class">
<span>class <span class="ident">SafeOperationVisitor</span></span>
<span>(</span><span>guaranteed_names)</span>
</code></dt>
<dd>
<div class="desc"><p>A node visitor base class that walks the abstract syntax tree and calls a
visitor function for every node found.
This function may return a value
which is forwarded by the <code>visit</code> method.</p>
<p>This class is meant to be subclassed, with the subclass adding visitor
methods.</p>
<p>Per default the visitor functions for the nodes are <code>'visit_'</code> +
class name of the node.
So a <code>TryFinally</code> node visit function would
be <code>visit_TryFinally</code>.
This behavior can be changed by overriding
the <code>visit</code> method.
If no visitor function exists for a node
(return value <code>None</code>) the <code>generic_visit</code> visitor is used instead.</p>
<p>Don't use the <code>NodeVisitor</code> if you want to apply changes to nodes during
traversing.
For this a special visitor exists (<code>NodeTransformer</code>) that
allows modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SafeOperationVisitor(CompilingNodeVisitor):
    step = &#34;Collecting computations that can not throw errors&#34;

    def __init__(self, guaranteed_names):
        self.guaranteed_names = guaranteed_names

    def generic_visit(self, node: AST) -&gt; bool:
        # generally every operation is unsafe except we whitelist it
        return False

    def visit_Lambda(self, node: Lambda) -&gt; bool:
        # lambda definition is fine as it actually doesn&#39;t compute anything
        return True

    def visit_Constant(self, node: Constant) -&gt; bool:
        # Constants can not fail
        return True

    def visit_RawPlutoExpr(self, node) -&gt; bool:
        # these expressions are not evaluated further
        return True

    def visit_Name(self, node: Name) -&gt; bool:
        return node.id in self.guaranteed_names</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="hebi.util.CompilingNodeVisitor" href="../util.html#hebi.util.CompilingNodeVisitor">CompilingNodeVisitor</a></li>
<li><a title="hebi.typed_ast.TypedNodeVisitor" href="../typed_ast.html#hebi.typed_ast.TypedNodeVisitor">TypedNodeVisitor</a></li>
<li>ast.NodeVisitor</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.step"><code class="name">var <span class="ident">step</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node: _ast.AST) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node: AST) -&gt; bool:
    # generally every operation is unsafe except we whitelist it
    return False</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node: _ast.Constant) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node: Constant) -&gt; bool:
    # Constants can not fail
    return True</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Lambda"><code class="name flex">
<span>def <span class="ident">visit_Lambda</span></span>(<span>self, node: _ast.Lambda) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Lambda(self, node: Lambda) -&gt; bool:
    # lambda definition is fine as it actually doesn&#39;t compute anything
    return True</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node: _ast.Name) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node: Name) -&gt; bool:
    return node.id in self.guaranteed_names</code></pre>
</details>
</dd>
<dt id="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_RawPlutoExpr"><code class="name flex">
<span>def <span class="ident">visit_RawPlutoExpr</span></span>(<span>self, node) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_RawPlutoExpr(self, node) -&gt; bool:
    # these expressions are not evaluated further
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="hebi.util.CompilingNodeVisitor" href="../util.html#hebi.util.CompilingNodeVisitor">CompilingNodeVisitor</a></b></code>:
<ul class="hlist">
<li><code><a title="hebi.util.CompilingNodeVisitor.visit" href="../typed_ast.html#hebi.typed_ast.TypedNodeVisitor.visit">visit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hebi.optimize" href="index.html">hebi.optimize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hebi.optimize.optimize_remove_deadvars.NameLoadCollector" href="#hebi.optimize.optimize_remove_deadvars.NameLoadCollector">NameLoadCollector</a></code></h4>
<ul class="">
<li><code><a title="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.step" href="#hebi.optimize.optimize_remove_deadvars.NameLoadCollector.step">step</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_ClassDef" href="#hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_FunctionDef" href="#hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_Name" href="#hebi.optimize.optimize_remove_deadvars.NameLoadCollector.visit_Name">visit_Name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars">OptimizeRemoveDeadvars</a></code></h4>
<ul class="">
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.enter_scope" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.enter_scope">enter_scope</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.exit_scope" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.exit_scope">exit_scope</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed">guaranteed</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed_avail_names" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.guaranteed_avail_names">guaranteed_avail_names</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.loaded_vars" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.loaded_vars">loaded_vars</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.set_guaranteed" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.set_guaranteed">set_guaranteed</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.step" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.step">step</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_AnnAssign" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_AnnAssign">visit_AnnAssign</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Assign" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Assign">visit_Assign</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_ClassDef" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_ClassDef">visit_ClassDef</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_For" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_For">visit_For</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_FunctionDef" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_FunctionDef">visit_FunctionDef</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_If" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_If">visit_If</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Module" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_Module">visit_Module</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_While" href="#hebi.optimize.optimize_remove_deadvars.OptimizeRemoveDeadvars.visit_While">visit_While</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor">SafeOperationVisitor</a></code></h4>
<ul class="two-column">
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.generic_visit" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.generic_visit">generic_visit</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.step" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.step">step</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Constant" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Lambda" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Lambda">visit_Lambda</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Name" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_Name">visit_Name</a></code></li>
<li><code><a title="hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_RawPlutoExpr" href="#hebi.optimize.optimize_remove_deadvars.SafeOperationVisitor.visit_RawPlutoExpr">visit_RawPlutoExpr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>